<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>MiniSheet</title>
    <style>
      :root {
        --bg: #ececef;
        --panel: #f3f3f5;
        --line: #d5d5da;
        --text: #1d2029;
        --active: #305596;
        --active-soft: #6aa8f1;
        --nav-h: 56px;
        --const-h: 86px;
        --formula-h: 56px;
        --keypad-h: 238px;
      }

      * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
      }

      button,
      input,
      select {
        font: inherit;
      }

      .nav {
        position: fixed;
        top: env(safe-area-inset-top);
        left: 0;
        right: 0;
        height: var(--nav-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 34px 1fr 34px;
        gap: 6px;
        align-items: center;
        padding: 6px 8px;
        z-index: 60;
      }

      .arrow {
        width: 34px;
        height: 30px;
        border: 0;
        background: transparent;
        font-size: 18px;
      }

      .title-block {
        display: grid;
        gap: 1px;
        min-width: 0;
      }

      .title-line {
        font-size: 16px;
        line-height: 1.1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .sheet-line {
        display: flex;
        gap: 8px;
        align-items: baseline;
        white-space: nowrap;
      }

      .sheet-index {
        font-size: 12px;
        font-weight: 600;
      }

      .sheet-name {
        font-size: 12px;
        color: #4f5466;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .constants-strip {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h));
        left: 0;
        right: 0;
        height: var(--const-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 52px repeat(5, minmax(0, 1fr));
        z-index: 50;
      }

      .clear-cell,
      .const-cell {
        border-right: 1px solid var(--line);
        padding: 6px 4px;
        display: grid;
        gap: 4px;
        align-content: center;
      }

      .clear-cell {
        place-items: center;
      }

      .key-active {
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        background: var(--active);
        color: #fff;
        display: grid;
        place-items: center;
        width: 42px;
        height: 42px;
        font-size: 16px;
      }

      .const-top {
        border-radius: 8px;
        background: var(--active);
        color: #fff;
        min-height: 34px;
        display: grid;
        align-content: center;
        justify-items: center;
        padding: 4px;
      }

      .const-top .letter {
        font-size: 12px;
        line-height: 1;
      }

      .const-top .name {
        font-size: 11px;
        font-weight: 600;
      }

      .const-cell input {
        width: 100%;
        height: 30px;
        border: 1px solid #c7c7ce;
        border-radius: 7px;
        background: #efefef;
        font-size: 14px;
        padding: 2px 6px;
      }

      .formula-strip {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h) + var(--const-h));
        left: 0;
        right: 0;
        height: var(--formula-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 30px 1fr auto;
        align-items: center;
        gap: 6px;
        padding: 6px 8px;
        z-index: 49;
      }

      .fx-eq {
        font-size: 26px;
        font-weight: 700;
        text-align: center;
      }

      .formula-input {
        width: 100%;
        min-width: 0;
        height: 42px;
        border: 2px solid var(--active-soft);
        border-radius: 10px;
        box-shadow: 0 0 0 1px rgba(106, 168, 241, 0.35) inset;
        background: #f0f0f2;
        font-size: 14px;
        padding: 6px 10px;
      }

      .toggle {
        font-size: 12px;
        white-space: nowrap;
      }

      .grid-wrap {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h) + var(--const-h) + var(--formula-h));
        left: 0;
        right: 0;
        bottom: calc(env(safe-area-inset-bottom) + var(--keypad-h));
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        background: #f7f7f8;
        z-index: 20;
      }

      table {
        border-collapse: separate;
        border-spacing: 0;
        width: 100%;
        table-layout: fixed;
      }

      col.col-num { width: 10%; }
      col.col-main { width: 17%; }
      col.col-result { width: 22%; }

      th,
      td {
        border-right: 1px solid var(--line);
        border-bottom: 1px solid var(--line);
        height: 48px;
        background: #f1f1f3;
      }

      th:last-child,
      td:last-child {
        border-right: 0;
      }

      thead th {
        position: sticky;
        top: 0;
        z-index: 7;
      }

      .num-head,
      .num {
        text-align: center;
        position: sticky;
        left: 0;
        background: #f1f1f3;
        z-index: 8;
        font-size: 15px;
      }

      .num-head {
        font-size: 17px;
        font-weight: 700;
      }

      .col-head {
        padding: 4px;
        background: #ececef;
      }

      .head-pill {
        background: var(--active);
        color: #fff;
        border-radius: 8px;
        min-height: 38px;
        display: grid;
        align-content: center;
        justify-items: center;
      }

      .head-pill .letter { font-size: 14px; }
      .head-pill .name { font-size: 11px; font-weight: 700; }

      .result-head,
      .result-cell {
        position: sticky;
        right: 0;
        z-index: 6;
      }

      .result-head { z-index: 9; }

      tfoot td {
        position: sticky;
        bottom: 0;
        z-index: 10;
        background: var(--panel);
        padding: 4px;
        height: 58px;
      }

      tfoot .num {
        font-weight: 700;
        font-size: 18px;
      }

      .stat-cell {
        border: 1px solid #d8d8de;
        border-radius: 14px;
        background: #ececf1;
        height: 48px;
        display: grid;
        grid-template-rows: 1fr 1fr;
        align-items: center;
        padding: 1px 6px;
      }

      .stat-cell select,
      .stat-cell output {
        border: 0;
        background: transparent;
        color: #2584e6;
        font-size: 12px;
        width: 100%;
      }

      .keypad {
        position: fixed;
        left: 0;
        right: 0;
        bottom: env(safe-area-inset-bottom);
        height: var(--keypad-h);
        padding: 6px;
        background: #7082a7;
        border-top: 1px solid #5d6f97;
        z-index: 41;
        transition: height 0.2s ease;
      }

      .keys {
        height: 100%;
        display: grid;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        grid-template-rows: repeat(6, minmax(0, 1fr));
        gap: 6px;
      }

      .key {
        border: 0;
        border-radius: 8px;
        background: var(--active);
        color: #fff;
        font-size: 18px;
      }

      .key.light {
        background: transparent;
        color: #f0f3fa;
        border: 1px solid transparent;
      }

      .key.enter {
        background: #7f88a0;
      }

      .keypad.minimized {
        height: 56px;
      }

      .keypad.minimized .keys {
        grid-template-rows: 1fr;
      }

      .keypad.minimized .key:nth-child(n + 7) {
        display: none;
      }

      .editable-cell {
        padding: 0;
      }

      .cell-input {
        width: 100%;
        height: 100%;
        border: 0;
        background: transparent;
        padding: 0 8px;
        font-size: 15px;
      }

      .is-active-target {
        outline: 2px solid var(--active-soft);
        outline-offset: -2px;
      }
    </style>
  </head>
  <body>
    <header class="nav">
      <button class="arrow" aria-label="Previous sheet">◀</button>
      <div class="title-block">
        <div class="title-line" contenteditable="true" role="textbox" aria-label="Sheet title">Proportion: A/B = C/Result | A:B::C:Result</div>
        <div class="sheet-line"><span class="sheet-index">2</span><span class="sheet-name">A:B::C:Result</span></div>
      </div>
      <button class="arrow" aria-label="Next sheet">▶</button>
    </header>

    <section class="constants-strip" aria-label="Constants strip">
      <div class="clear-cell"><button class="key-active" aria-label="Clear">C</button></div>
      <div class="const-cell"><div class="const-top"><div class="letter">V</div><div class="name">const1</div></div><input inputmode="decimal" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">W</div><div class="name">const2</div></div><input inputmode="decimal" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">X</div><div class="name">const3</div></div><input inputmode="decimal" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">Y</div><div class="name">const4</div></div><input inputmode="decimal" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">Z</div><div class="name">const5</div></div><input inputmode="decimal" value="" /></div>
    </section>

    <section class="formula-strip" aria-label="Formula editor strip">
      <div class="fx-eq">=</div>
      <input class="formula-input" value="(B*C)/A+Y" aria-label="Formula editor" />
      <div class="toggle">A / <strong>Name</strong></div>
    </section>

    <main class="grid-wrap" aria-label="Grid area">
      <table>
        <colgroup>
          <col class="col-num" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-result" />
        </colgroup>
        <thead>
          <tr>
            <th class="num-head">#</th>
            <th class="col-head"><div class="head-pill"><div class="letter">A</div><div class="name">value1</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">B</div><div class="name">value2</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">C</div><div class="name">value3</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">D</div><div class="name">unused</div></div></th>
            <th class="col-head result-head" role="button" tabindex="0" aria-label="Compute results"><div class="head-pill"><div class="letter">Result</div><div class="name">&nbsp;</div></div></th>
          </tr>
        </thead>
        <tbody>
          <tr><td class="num">1</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">2</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">3</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">4</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">5</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">6</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">7</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">8</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">9</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">10</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">11</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">12</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">13</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">14</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">15</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">16</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">17</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">18</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">19</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">20</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
        </tbody>
        <tfoot>
          <tr>
            <td class="num">#</td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
          </tr>
        </tfoot>
      </table>
    </main>

    <section class="keypad" aria-label="Bottom keypad">
      <div class="keys">
        <button class="key">↺</button><button class="key">⌨︎</button><button class="key">↕</button><button class="key">:</button><button class="key">√</button><button class="key">⌫</button>
        <button class="key light">&lt;</button><button class="key light">&gt;</button><button class="key">(</button><button class="key">)</button><button class="key">^</button><button class="key">/</button>
        <button class="key light">IF</button><button class="key light">AVG</button><button class="key">7</button><button class="key">8</button><button class="key">9</button><button class="key">*</button>
        <button class="key light">AND</button><button class="key light">SUM</button><button class="key">4</button><button class="key">5</button><button class="key">6</button><button class="key">−</button>
        <button class="key light">OR</button><button class="key light">MAX</button><button class="key">1</button><button class="key">2</button><button class="key">3</button><button class="key">+</button>
        <button class="key light">NOT</button><button class="key light">MIN</button><button class="key">0</button><button class="key">.</button><button class="key">,</button><button class="key enter">=</button>
      </div>
    </section>

    <script>
      (() => {
        const keypad = document.querySelector('.keypad');
        const keys = [...document.querySelectorAll('.keypad .key')];
        const minimizeKey = keys.find((key) => key.textContent.trim() === '↕');
        const undoKey = keys.find((key) => key.textContent.trim() === '↺');
        const backspaceKey = keys.find((key) => key.textContent.trim() === '⌫');
        const leftKey = keys.find((key) => key.textContent.trim() === '<');
        const rightKey = keys.find((key) => key.textContent.trim() === '>');
        const resultKey = keys.find((key) => key.textContent.trim() === '=');
        const sheetNavButtons = [...document.querySelectorAll('.nav .arrow')];
        const resultHeaderTrigger = document.querySelector('th.result-head');

        const formulaInput = document.querySelector('.formula-input');
        const constantInputs = [...document.querySelectorAll('.const-cell input')];
        const dataRows = [...document.querySelectorAll('tbody tr')];
        const statCells = [...document.querySelectorAll('tfoot .stat-cell')];
        const titleFields = [
          document.querySelector('.title-line'),
          document.querySelector('.sheet-name')
        ].filter(Boolean);

        dataRows.forEach((row) => {
          [...row.children].forEach((cell, index) => {
            if (index === 0 || cell.classList.contains('result-cell')) {
              return;
            }
            cell.classList.add('editable-cell');
            cell.innerHTML = '<input class="cell-input" inputmode="none" readonly value="" aria-label="Grid cell value" />';
          });
        });

        const cellInputs = [...document.querySelectorAll('.cell-input')];
        const rowBindings = dataRows.map((row) => ({
          inputs: [...row.querySelectorAll('.cell-input')],
          resultCell: row.querySelector('.result-cell')
        }));
        const numericTargets = [...constantInputs, formulaInput, ...cellInputs];
        const editableTargets = [...numericTargets, ...titleFields];

        let activeTarget = null;
        let initialValueOnFocus = '';

        const isInput = (el) => el instanceof HTMLInputElement;
        const getText = (el) => (isInput(el) ? el.value : (el.textContent || ''));

        const setText = (el, value) => {
          if (isInput(el)) {
            el.value = value;
            return;
          }
          el.textContent = value;
        };

        const getSelection = (el) => {
          if (isInput(el)) {
            return {
              start: el.selectionStart ?? el.value.length,
              end: el.selectionEnd ?? el.value.length
            };
          }

          const selection = window.getSelection();
          if (!selection || selection.rangeCount === 0 || !el.contains(selection.anchorNode)) {
            const end = getText(el).length;
            return { start: end, end };
          }

          const range = selection.getRangeAt(0);
          const preRange = range.cloneRange();
          preRange.selectNodeContents(el);
          preRange.setEnd(range.startContainer, range.startOffset);
          const start = preRange.toString().length;

          const postRange = range.cloneRange();
          postRange.selectNodeContents(el);
          postRange.setEnd(range.endContainer, range.endOffset);
          const end = postRange.toString().length;

          return { start, end };
        };

        const setSelection = (el, start, end = start) => {
          if (isInput(el)) {
            el.setSelectionRange(start, end);
            return;
          }

          const textNode = el.firstChild || el.appendChild(document.createTextNode(getText(el)));
          const range = document.createRange();
          const safeStart = Math.max(0, Math.min(start, textNode.textContent.length));
          const safeEnd = Math.max(0, Math.min(end, textNode.textContent.length));
          range.setStart(textNode, safeStart);
          range.setEnd(textNode, safeEnd);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        };

        const activateTarget = (target) => {
          if (!target || activeTarget === target) {
            return;
          }

          if (activeTarget) {
            activeTarget.classList.remove('is-active-target');
          }

          activeTarget = target;
          activeTarget.classList.add('is-active-target');
          initialValueOnFocus = getText(target);
        };

        const blurActiveTarget = () => {
          if (!activeTarget) return;
          activeTarget.classList.remove('is-active-target');
          if (document.activeElement instanceof HTMLElement) {
            document.activeElement.blur();
          }
          activeTarget = null;
          initialValueOnFocus = '';
        };

        const insertIntoTarget = (text) => {
          if (!activeTarget) return;
          const value = getText(activeTarget);
          const { start, end } = getSelection(activeTarget);
          const nextValue = value.slice(0, start) + text + value.slice(end);
          setText(activeTarget, nextValue);
          const nextCursor = start + text.length;
          setSelection(activeTarget, nextCursor);
        };

        const deleteBackward = () => {
          if (!activeTarget) return;
          const value = getText(activeTarget);
          const { start, end } = getSelection(activeTarget);

          if (start !== end) {
            const nextValue = value.slice(0, start) + value.slice(end);
            setText(activeTarget, nextValue);
            setSelection(activeTarget, start);
            return;
          }

          if (start === 0) return;
          const nextValue = value.slice(0, start - 1) + value.slice(start);
          setText(activeTarget, nextValue);
          setSelection(activeTarget, start - 1);
        };

        const moveCursor = (delta) => {
          if (!activeTarget) return;
          const { start, end } = getSelection(activeTarget);
          const base = delta < 0 ? start : end;
          const next = Math.max(0, Math.min(base + delta, getText(activeTarget).length));
          setSelection(activeTarget, next);
        };

        const suppressNativeTyping = (event) => {
          event.preventDefault();
        };

        const toNumericOrZero = (rawValue) => {
          const value = String(rawValue ?? '').trim();
          if (!value) return 0;
          const numeric = Number(value);
          if (!Number.isFinite(numeric)) {
            throw new Error('NON_NUMERIC');
          }
          return numeric;
        };

        const tokenize = (source) => {
          const tokens = [];
          const text = String(source ?? '');
          let index = 0;

          while (index < text.length) {
            const char = text[index];

            if (/\s/.test(char)) {
              index += 1;
              continue;
            }

            if ((char >= '0' && char <= '9') || char === '.') {
              let end = index;
              let dotCount = 0;
              while (end < text.length && ((text[end] >= '0' && text[end] <= '9') || text[end] === '.')) {
                if (text[end] === '.') dotCount += 1;
                end += 1;
              }
              if (dotCount > 1) throw new SyntaxError('Invalid number');
              const literal = text.slice(index, end);
              if (literal === '.') throw new SyntaxError('Invalid number');
              tokens.push({ type: 'number', value: Number(literal) });
              index = end;
              continue;
            }

            const normalized = char === '−' ? '-' : char;
            if ('+-*/^'.includes(normalized)) {
              tokens.push({ type: 'operator', value: normalized });
              index += 1;
              continue;
            }

            if (normalized === '(' || normalized === ')') {
              tokens.push({ type: 'paren', value: normalized });
              index += 1;
              continue;
            }

            if (normalized === ',') {
              tokens.push({ type: 'comma', value: ',' });
              index += 1;
              continue;
            }

            if (normalized === '√') {
              tokens.push({ type: 'root', value: '√' });
              index += 1;
              continue;
            }

            if (/[A-Za-z]/.test(normalized)) {
              const upper = normalized.toUpperCase();
              if (!'ABCDVWXYZ'.includes(upper)) {
                throw new SyntaxError('Unknown variable');
              }
              tokens.push({ type: 'variable', value: upper });
              index += 1;
              continue;
            }

            throw new SyntaxError('Unexpected token');
          }

          return tokens;
        };

        const parse = (tokens) => {
          let cursor = 0;
          const peek = () => tokens[cursor];
          const consume = () => tokens[cursor++];

          const parsePrimary = () => {
            const token = peek();
            if (!token) {
              throw new SyntaxError('Unexpected end');
            }

            if (token.type === 'number') {
              consume();
              return { type: 'number', value: token.value };
            }

            if (token.type === 'variable') {
              consume();
              return { type: 'variable', name: token.value };
            }

            if (token.type === 'paren' && token.value === '(') {
              consume();
              const expression = parseExpression();
              const close = consume();
              if (!close || close.type !== 'paren' || close.value !== ')') {
                throw new SyntaxError('Missing close paren');
              }
              return expression;
            }

            if (token.type === 'root') {
              consume();
              const open = consume();
              if (!open || open.type !== 'paren' || open.value !== '(') {
                throw new SyntaxError('Root call requires parenthesis');
              }

              const first = parseExpression();
              const next = peek();
              if (next && next.type === 'comma') {
                consume();
                const second = parseExpression();
                const close = consume();
                if (!close || close.type !== 'paren' || close.value !== ')') {
                  throw new SyntaxError('Missing close paren');
                }
                return { type: 'root', degree: first, radicand: second };
              }

              const close = consume();
              if (!close || close.type !== 'paren' || close.value !== ')') {
                throw new SyntaxError('Missing close paren');
              }
              return { type: 'root', degree: null, radicand: first };
            }

            throw new SyntaxError('Unexpected token');
          };

          const parseUnary = () => {
            const token = peek();
            if (token && token.type === 'operator' && (token.value === '+' || token.value === '-')) {
              consume();
              return { type: 'unary', operator: token.value, argument: parseUnary() };
            }
            return parsePrimary();
          };

          const parsePower = () => {
            let left = parseUnary();
            const token = peek();
            if (token && token.type === 'operator' && token.value === '^') {
              consume();
              const right = parsePower();
              left = { type: 'binary', operator: '^', left, right };
            }
            return left;
          };

          const parseTerm = () => {
            let left = parsePower();
            while (true) {
              const token = peek();
              if (!token || token.type !== 'operator' || !'*/'.includes(token.value)) {
                return left;
              }
              consume();
              left = { type: 'binary', operator: token.value, left, right: parsePower() };
            }
          };

          const parseExpression = () => {
            let left = parseTerm();
            while (true) {
              const token = peek();
              if (!token || token.type !== 'operator' || !'+-'.includes(token.value)) {
                return left;
              }
              consume();
              left = { type: 'binary', operator: token.value, left, right: parseTerm() };
            }
          };

          const ast = parseExpression();
          if (cursor < tokens.length) {
            throw new SyntaxError('Trailing tokens');
          }
          return ast;
        };

        const evaluateAst = (node, scope) => {
          switch (node.type) {
            case 'number':
              return node.value;
            case 'variable':
              return scope[node.name] ?? 0;
            case 'unary': {
              const value = evaluateAst(node.argument, scope);
              return node.operator === '-' ? -value : value;
            }
            case 'binary': {
              const left = evaluateAst(node.left, scope);
              const right = evaluateAst(node.right, scope);
              if (node.operator === '+') return left + right;
              if (node.operator === '-') return left - right;
              if (node.operator === '*') return left * right;
              if (node.operator === '/') {
                if (right === 0) throw new Error('DIV_0');
                return left / right;
              }
              if (node.operator === '^') return left ** right;
              throw new Error('EVAL');
            }
            case 'root': {
              const radicand = evaluateAst(node.radicand, scope);
              if (!node.degree) {
                return Math.sqrt(radicand);
              }
              const degree = evaluateAst(node.degree, scope);
              if (degree === 0) throw new Error('DIV_0');
              return radicand ** (1 / degree);
            }
            default:
              throw new Error('EVAL');
          }
        };

        const mapErrorToCellText = (error) => {
          if (error instanceof SyntaxError) {
            return 'Syntax';
          }
          if (error?.message === 'DIV_0') {
            return 'DIV/0';
          }
          return 'Error';
        };

        const formatNumber = (value) => {
          if (!Number.isFinite(value)) return 'Error';
          const normalized = Object.is(value, -0) ? 0 : value;
          if (Number.isInteger(normalized)) return String(normalized);
          return normalized.toFixed(8).replace(/\.?0+$/, '');
        };

        const getColumnNumbers = (columnIndex) => {
          if (columnIndex < 4) {
            return rowBindings
              .map((row) => Number(row.inputs[columnIndex]?.value))
              .filter((value) => Number.isFinite(value));
          }

          return rowBindings
            .map((row) => Number(row.resultCell.textContent))
            .filter((value) => Number.isFinite(value));
        };

        const applyStat = (values, statName) => {
          if (!values.length) return '—';
          if (statName === 'Sum') return formatNumber(values.reduce((total, value) => total + value, 0));
          if (statName === 'Avg') return formatNumber(values.reduce((total, value) => total + value, 0) / values.length);
          if (statName === 'Min') return formatNumber(Math.min(...values));
          if (statName === 'Max') return formatNumber(Math.max(...values));
          if (statName === 'Count') return String(values.length);
          return '—';
        };

        const recomputeStats = () => {
          statCells.forEach((statCell, index) => {
            const select = statCell.querySelector('select');
            const output = statCell.querySelector('output');
            const statName = select?.value ?? '--';
            if (statName === '--') {
              output.textContent = '—';
              return;
            }
            const values = getColumnNumbers(index);
            output.textContent = applyStat(values, statName);
          });
        };

        const computeAllRows = () => {
          let ast;
          try {
            ast = parse(tokenize(formulaInput.value));
          } catch (error) {
            rowBindings.forEach((row) => {
              row.resultCell.textContent = mapErrorToCellText(error);
            });
            recomputeStats();
            return;
          }

          let constants;
          try {
            constants = {
              V: toNumericOrZero(constantInputs[0]?.value),
              W: toNumericOrZero(constantInputs[1]?.value),
              X: toNumericOrZero(constantInputs[2]?.value),
              Y: toNumericOrZero(constantInputs[3]?.value),
              Z: toNumericOrZero(constantInputs[4]?.value)
            };
          } catch (error) {
            rowBindings.forEach((row) => {
              row.resultCell.textContent = mapErrorToCellText(error);
            });
            recomputeStats();
            return;
          }

          rowBindings.forEach((row) => {
            try {
              const scope = {
                ...constants,
                A: toNumericOrZero(row.inputs[0]?.value),
                B: toNumericOrZero(row.inputs[1]?.value),
                C: toNumericOrZero(row.inputs[2]?.value),
                D: toNumericOrZero(row.inputs[3]?.value)
              };
              const value = evaluateAst(ast, scope);
              row.resultCell.textContent = formatNumber(value);
            } catch (error) {
              row.resultCell.textContent = mapErrorToCellText(error);
            }
          });

          recomputeStats();
        };

        numericTargets.forEach((target) => {
          target.setAttribute('inputmode', 'none');
          target.readOnly = true;
          target.addEventListener('focus', () => activateTarget(target));
          target.addEventListener('pointerdown', () => activateTarget(target));
          target.addEventListener('keydown', suppressNativeTyping);
          target.addEventListener('beforeinput', suppressNativeTyping);
          target.addEventListener('paste', suppressNativeTyping);
        });

        titleFields.forEach((target) => {
          target.setAttribute('contenteditable', 'true');
          target.addEventListener('focus', () => activateTarget(target));
          target.addEventListener('pointerup', () => activateTarget(target));
        });

        const handleKeyPress = (key) => {
          const label = key.textContent.trim();

          if (key === minimizeKey) {
            keypad.classList.toggle('minimized');
            return;
          }
          if (key === undoKey) {
            if (!activeTarget) return;
            setText(activeTarget, initialValueOnFocus);
            setSelection(activeTarget, getText(activeTarget).length);
            return;
          }
          if (key === backspaceKey) {
            deleteBackward();
            return;
          }
          if (key === leftKey) {
            moveCursor(-1);
            return;
          }
          if (key === rightKey) {
            moveCursor(1);
            return;
          }
          if (key === resultKey) {
            blurActiveTarget();
            computeAllRows();
            return;
          }
          if (label === '⌨︎') {
            return;
          }

          const insertText = label === '−' ? '-' : label;
          insertIntoTarget(insertText);
        };

        keys.forEach((key) => {
          let pointerTriggered = false;
          key.addEventListener('pointerdown', (event) => {
            event.preventDefault();
            pointerTriggered = true;
            handleKeyPress(key);
          });
          key.addEventListener('click', (event) => {
            event.preventDefault();
            if (pointerTriggered) {
              pointerTriggered = false;
              return;
            }
            handleKeyPress(key);
          });
        });

        sheetNavButtons.forEach((button) => {
          button.addEventListener('click', () => {
            blurActiveTarget();
          });
        });

        if (resultHeaderTrigger) {
          let headerPointerTriggered = false;
          resultHeaderTrigger.addEventListener('pointerdown', (event) => {
            event.preventDefault();
            headerPointerTriggered = true;
            blurActiveTarget();
            computeAllRows();
          });
          resultHeaderTrigger.addEventListener('click', (event) => {
            event.preventDefault();
            if (headerPointerTriggered) {
              headerPointerTriggered = false;
              return;
            }
            blurActiveTarget();
            computeAllRows();
          });
          resultHeaderTrigger.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter' && event.key !== ' ') return;
            event.preventDefault();
            blurActiveTarget();
            computeAllRows();
          });
        }

        editableTargets.forEach((target) => {
          target.addEventListener('blur', () => {
            if (activeTarget === target) {
              target.classList.remove('is-active-target');
              activeTarget = null;
              initialValueOnFocus = '';
            }
          });
        });

        document.addEventListener('keydown', (event) => {
          if (event.key !== 'Enter') return;
          if (!activeTarget || !editableTargets.includes(activeTarget)) return;
          event.preventDefault();
          blurActiveTarget();
          computeAllRows();
        });

        statCells.forEach((cell) => {
          const select = cell.querySelector('select');
          select?.addEventListener('change', recomputeStats);
        });
      })();
    </script>
  </body>
</html>
