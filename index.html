<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>MiniSheet</title>
    <style>
      :root {
        --bg: #ececef;
        --panel: #f3f3f5;
        --line: #d5d5da;
        --text: #1d2029;
        --active: #305596;
        --active-soft: #6aa8f1;
        --nav-h: 56px;
        --const-h: 86px;
        --formula-h: 56px;
        --keypad-h: 238px;
      }

      * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
      }

      button,
      input,
      select {
        font: inherit;
      }

      .nav {
        position: fixed;
        top: env(safe-area-inset-top);
        left: 0;
        right: 0;
        height: var(--nav-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 34px 1fr 34px;
        gap: 6px;
        align-items: center;
        padding: 6px 8px;
        z-index: 60;
      }

      .arrow {
        width: 34px;
        height: 30px;
        border: 0;
        background: transparent;
        font-size: 18px;
      }

      .title-block {
        min-width: 0;
      }

      .sheet-line {
        display: flex;
        gap: 8px;
        align-items: baseline;
        white-space: nowrap;
        min-width: 0;
      }

      .sheet-index {
        font-size: 12px;
        font-weight: 600;
      }

      .sheet-name {
        font-size: 16px;
        line-height: 1.1;
        color: var(--text);
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
        min-width: 0;
      }

      .constants-strip {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h));
        left: 0;
        right: 0;
        height: var(--const-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 52px repeat(5, minmax(0, 1fr));
        z-index: 50;
      }

      .clear-cell,
      .const-cell {
        border-right: 1px solid var(--line);
        padding: 6px 4px;
        display: grid;
        gap: 4px;
        align-content: center;
      }

      .clear-cell {
        place-items: center;
      }

      .key-active {
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        background: var(--active);
        color: #fff;
        display: grid;
        place-items: center;
        width: 42px;
        height: 42px;
        font-size: 16px;
      }

      .const-top {
        border-radius: 8px;
        background: var(--active);
        color: #fff;
        min-height: 34px;
        display: grid;
        align-content: center;
        justify-items: center;
        padding: 4px;
      }

      .const-top .letter {
        font-size: 12px;
        line-height: 1;
      }

      .const-top .name {
        font-size: 11px;
        font-weight: 600;
      }

      .const-cell input {
        width: 100%;
        height: 30px;
        border: 1px solid #c7c7ce;
        border-radius: 7px;
        background: #efefef;
        font-size: 14px;
        padding: 2px 6px;
      }

      .formula-strip {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h) + var(--const-h));
        left: 0;
        right: 0;
        height: var(--formula-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 30px 1fr auto;
        align-items: center;
        gap: 6px;
        padding: 6px 8px;
        z-index: 49;
      }

      .fx-eq {
        font-size: 26px;
        font-weight: 700;
        text-align: center;
      }

      .formula-input {
        width: 100%;
        min-width: 0;
        height: 42px;
        border: 2px solid var(--active-soft);
        border-radius: 10px;
        box-shadow: 0 0 0 1px rgba(106, 168, 241, 0.35) inset;
        background: #f0f0f2;
        font-size: 14px;
        padding: 6px 10px;
      }

      .toggle {
        font-size: 12px;
        white-space: nowrap;
      }

      .grid-wrap {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h) + var(--const-h) + var(--formula-h));
        left: 0;
        right: 0;
        bottom: calc(env(safe-area-inset-bottom) + var(--keypad-h));
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        background: #f7f7f8;
        z-index: 20;
      }

      table {
        border-collapse: separate;
        border-spacing: 0;
        width: 100%;
        table-layout: fixed;
      }

      col.col-num { width: 10%; }
      col.col-main { width: 17%; }
      col.col-result { width: 22%; }

      th,
      td {
        border-right: 1px solid var(--line);
        border-bottom: 1px solid var(--line);
        height: 48px;
        background: #f1f1f3;
      }

      th:last-child,
      td:last-child {
        border-right: 0;
      }

      thead th {
        position: sticky;
        top: 0;
        z-index: 7;
      }

      .num-head,
      .num {
        text-align: center;
        position: sticky;
        left: 0;
        background: #f1f1f3;
        z-index: 8;
        font-size: 15px;
      }

      .num-head {
        font-size: 17px;
        font-weight: 700;
      }

      .col-head {
        padding: 4px;
        background: #ececef;
      }

      .head-pill {
        background: var(--active);
        color: #fff;
        border-radius: 8px;
        min-height: 38px;
        display: grid;
        align-content: center;
        justify-items: center;
      }

      .head-pill .letter { font-size: 14px; }
      .head-pill .name { font-size: 11px; font-weight: 700; }

      .result-head,
      .result-cell {
        position: sticky;
        right: 0;
        z-index: 6;
      }

      .result-head { z-index: 9; }

      tfoot td {
        position: sticky;
        bottom: 0;
        z-index: 10;
        background: var(--panel);
        padding: 4px;
        height: 58px;
      }

      tfoot .num {
        font-weight: 700;
        font-size: 18px;
      }

      .stat-cell {
        border: 1px solid #d8d8de;
        border-radius: 14px;
        background: #ececf1;
        height: 48px;
        display: grid;
        grid-template-rows: 1fr 1fr;
        align-items: center;
        padding: 1px 6px;
      }

      .stat-cell select,
      .stat-cell output {
        border: 0;
        background: transparent;
        color: #2584e6;
        font-size: 12px;
        width: 100%;
      }

      .keypad {
        position: fixed;
        left: 0;
        right: 0;
        bottom: env(safe-area-inset-bottom);
        height: var(--keypad-h);
        padding: 6px;
        background: #7082a7;
        border-top: 1px solid #5d6f97;
        z-index: 41;
        transition: height 0.2s ease;
      }

      .keys {
        height: 100%;
        display: grid;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        grid-template-rows: repeat(6, minmax(0, 1fr));
        gap: 6px;
      }

      .key {
        border: 0;
        border-radius: 8px;
        background: var(--active);
        color: #fff;
        font-size: 18px;
      }

      .key.light {
        background: transparent;
        color: #f0f3fa;
        border: 1px solid transparent;
      }

      .key.enter {
        background: #7f88a0;
      }

      .keypad.minimized {
        height: 56px;
      }

      .keypad.minimized .keys {
        grid-template-rows: 1fr;
      }

      .keypad.minimized .key:nth-child(n + 7) {
        display: none;
      }

      .editable-cell {
        padding: 0;
      }

      .cell-input {
        width: 100%;
        height: 100%;
        border: 0;
        background: transparent;
        padding: 0 8px;
        font-size: 15px;
      }

      .is-active-target {
        outline: 2px solid var(--active-soft);
        outline-offset: -2px;
      }
    </style>
  </head>
  <body>
    <header class="nav">
      <button class="arrow" aria-label="Previous sheet">◀</button>
      <div class="title-block">
        <div class="sheet-line"><span class="sheet-index">1/2</span><span class="sheet-name">A:B::C:Result</span></div>
      </div>
      <button class="arrow" aria-label="Next sheet">▶</button>
    </header>

    <section class="constants-strip" aria-label="Constants strip">
      <div class="clear-cell"><button class="key-active" aria-label="Clear">C</button></div>
      <div class="const-cell"><div class="const-top"><div class="letter">V</div><div class="name">const1</div></div><input inputmode="none" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">W</div><div class="name">const2</div></div><input inputmode="none" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">X</div><div class="name">const3</div></div><input inputmode="none" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">Y</div><div class="name">const4</div></div><input inputmode="none" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">Z</div><div class="name">const5</div></div><input inputmode="none" value="" /></div>
    </section>

    <section class="formula-strip" aria-label="Formula editor strip">
      <div class="fx-eq">=</div>
      <input class="formula-input" value="(B*C)/A" aria-label="Formula editor" />
      <button class="toggle" type="button" aria-label="Toggle formula labels">A / <strong>Name</strong></button>
    </section>

    <main class="grid-wrap" aria-label="Grid area">
      <table>
        <colgroup>
          <col class="col-num" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-result" />
        </colgroup>
        <thead>
          <tr>
            <th class="num-head">#</th>
            <th class="col-head"><div class="head-pill"><div class="letter">A</div><div class="name">value1</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">B</div><div class="name">value2</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">C</div><div class="name">value3</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">D</div><div class="name">unused</div></div></th>
            <th class="col-head result-head" role="button" tabindex="0" aria-label="Compute results"><div class="head-pill"><div class="letter">Result</div><div class="name">&nbsp;</div></div></th>
          </tr>
        </thead>
        <tbody>
          <tr><td class="num">1</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">2</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">3</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">4</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">5</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">6</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">7</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">8</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">9</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">10</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">11</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">12</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">13</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">14</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">15</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">16</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">17</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">18</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">19</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">20</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
        </tbody>
        <tfoot>
          <tr>
            <td class="num">#</td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
          </tr>
        </tfoot>
      </table>
    </main>

    <section class="keypad" aria-label="Bottom keypad">
      <div class="keys">
        <button class="key">↺</button><button class="key">⌨︎</button><button class="key">↕</button><button class="key">:</button><button class="key">√</button><button class="key">⌫</button>
        <button class="key light">&lt;</button><button class="key light">&gt;</button><button class="key">(</button><button class="key">)</button><button class="key">^</button><button class="key">/</button>
        <button class="key light">IF</button><button class="key light">AVG</button><button class="key">7</button><button class="key">8</button><button class="key">9</button><button class="key">*</button>
        <button class="key light">AND</button><button class="key light">SUM</button><button class="key">4</button><button class="key">5</button><button class="key">6</button><button class="key">−</button>
        <button class="key light">OR</button><button class="key light">MAX</button><button class="key">1</button><button class="key">2</button><button class="key">3</button><button class="key">+</button>
        <button class="key light">NOT</button><button class="key light">MIN</button><button class="key">0</button><button class="key">.</button><button class="key">,</button><button class="key enter">=</button>
      </div>
    </section>

    <script>
      (() => {
        const ROW_COUNT = 20;
        const KEY_ORDER = ['A', 'B', 'C', 'D'];
        const CONST_ORDER = ['V', 'W', 'X', 'Y', 'Z'];
        const ALL_LETTERS = [...KEY_ORDER, ...CONST_ORDER];
        const STORAGE_KEY = 'minisheet-v2';

        const keypad = document.querySelector('.keypad');
        const keys = [...document.querySelectorAll('.keypad .key')];
        const minimizeKey = keys.find((key) => key.textContent.trim() === '↕');
        const undoKey = keys.find((key) => key.textContent.trim() === '↺');
        const backspaceKey = keys.find((key) => key.textContent.trim() === '⌫');
        const leftKey = keys.find((key) => key.textContent.trim() === '<');
        const rightKey = keys.find((key) => key.textContent.trim() === '>');
        const resultKey = keys.find((key) => key.textContent.trim() === '=');
        const sheetNavButtons = [...document.querySelectorAll('.nav .arrow')];
        const resultHeaderTrigger = document.querySelector('th.result-head');
        const clearButton = document.querySelector('.key-active');
        const toggleButton = document.querySelector('.toggle');
        const titleLine = document.querySelector('.title-line');
        const sheetIndexEl = document.querySelector('.sheet-index');
        const sheetNameLine = document.querySelector('.sheet-name');
        const formulaInput = document.querySelector('.formula-input');
        const constantInputs = [...document.querySelectorAll('.const-cell input')];
        const constTopEls = [...document.querySelectorAll('.const-top')];
        const dataRows = [...document.querySelectorAll('tbody tr')];
        const statCells = [...document.querySelectorAll('tfoot .stat-cell')];
        const headerPills = [...document.querySelectorAll('thead .head-pill')];

        const asyncStorage = {
          async get() {
            await Promise.resolve();
            const raw = localStorage.getItem(STORAGE_KEY);
            return raw ? JSON.parse(raw) : null;
          },
          async set(value) {
            await Promise.resolve();
            localStorage.setItem(STORAGE_KEY, JSON.stringify(value));
          }
        };

        const sheetTemplate = (idx) => {
          if (idx === 0) return { title: 'Proportion: A/B = C/Result', name: 'A:B::C:Result', formula: '(B*C)/A+Y' };
          if (idx === 1) return { title: 'Rule of three: A:B::C:Result', name: 'Rule of 3', formula: '(B*C)/A' };
          return { title: 'Blank sheet', name: `Sheet ${idx + 1}`, formula: '' };
        };

        const baseNames = { A: 'value1', B: 'value2', C: 'value3', D: 'unused', V: 'const1', W: 'const2', X: 'const3', Y: 'const4', Z: 'const5' };
        const makeBlankRows = () => Array.from({ length: ROW_COUNT }, () => ({ A: '', B: '', C: '', D: '', Result: '' }));
        const makeSheet = (idx) => {
          const t = sheetTemplate(idx);
          return { title: t.title, name: t.name, formulaCanonical: t.formula, names: { ...baseNames }, constants: { V: '', W: '', X: '', Y: '', Z: '' }, rows: makeBlankRows(), stats: ['--', '--', '--', '--', '--'] };
        };

        const state = { sheets: [makeSheet(0), makeSheet(1)], currentSheetIndex: 0, formulaMode: 'name', clearStage: 0 };

        let saveTimer = null;
        const scheduleSave = () => {
          if (saveTimer) clearTimeout(saveTimer);
          saveTimer = setTimeout(() => asyncStorage.set({ sheets: state.sheets, currentSheetIndex: state.currentSheetIndex, formulaMode: state.formulaMode }), 250);
        };

        dataRows.forEach((row) => {
          [...row.children].forEach((cell, index) => {
            if (index === 0 || cell.classList.contains('result-cell')) return;
            cell.classList.add('editable-cell');
            cell.innerHTML = '<input class="cell-input" inputmode="none" value="" aria-label="Grid cell value" />';
          });
        });

        const cellInputs = [...document.querySelectorAll('.cell-input')];
        const rowBindings = dataRows.map((row) => ({ inputs: [...row.querySelectorAll('.cell-input')], resultCell: row.querySelector('.result-cell') }));
        const headerNameEls = headerPills.slice(0, 4).map((pill) => pill.querySelector('.name'));
        const headerLetterEls = headerPills.slice(0, 4).map((pill) => pill.querySelector('.letter'));
        const constNameEls = constTopEls.map((pill) => pill.querySelector('.name'));
        const constLetterEls = constTopEls.map((pill) => pill.querySelector('.letter'));

        [...headerNameEls, ...constNameEls].forEach((el) => {
          if (!el) return;
          el.setAttribute('contenteditable', 'true');
          el.setAttribute('role', 'textbox');
        });

        let activeTarget = null;
        let initialValueOnFocus = '';

        const resetClearStage = () => { state.clearStage = 0; clearButton.textContent = 'C'; };
        const advanceClearStage = () => { state.clearStage = Math.min(3, state.clearStage + 1); clearButton.textContent = ['C', '#C', '#C', 'AC'][state.clearStage]; };
        const isInput = (el) => el instanceof HTMLInputElement;
        const getText = (el) => (isInput(el) ? el.value : (el.textContent || ''));
        const setText = (el, value) => { if (isInput(el)) el.value = value; else el.textContent = value; };

        const sanitizeNameMap = (sheet) => {
          const out = {};
          const seen = new Set();
          const reserved = new Set(['RESULT', 'SUM', 'AVG', 'MIN', 'MAX', 'COUNT', ...ALL_LETTERS]);
          ALL_LETTERS.forEach((letter) => {
            const raw = String(sheet.names[letter] ?? '').trim();
            let base = raw || letter;
            if (reserved.has(base.toUpperCase()) || /[^A-Za-z0-9_]/.test(base)) base = `[${base}]`;
            let next = base;
            let n = 2;
            while (seen.has(next.toUpperCase())) next = `${base}_${n++}`;
            seen.add(next.toUpperCase());
            out[letter] = next;
          });
          return out;
        };
        const buildNameToLetter = (sheet) => { const clean = sanitizeNameMap(sheet); const map = {}; Object.entries(clean).forEach(([k, v]) => { map[v] = k; }); return { clean, map }; };
        const canonicalToDisplay = (canonical, sheet) => state.formulaMode === 'letter' ? canonical : String(canonical || '').replace(/[A-Za-z]/g, (m) => buildNameToLetter(sheet).clean[m.toUpperCase()] || m);
        const displayToCanonical = (display, sheet) => {
          let expr = String(display || '');
          Object.entries(buildNameToLetter(sheet).map).sort((a, b) => b[0].length - a[0].length).forEach(([name, letter]) => { expr = expr.split(name).join(letter); });
          return expr;
        };

        const getSelection = (el) => {
          if (isInput(el)) return { start: el.selectionStart ?? 0, end: el.selectionEnd ?? 0 };
          const selection = window.getSelection();
          if (!selection || selection.rangeCount === 0 || !el.contains(selection.anchorNode)) { const end = getText(el).length; return { start: end, end }; }
          const range = selection.getRangeAt(0);
          const pre = range.cloneRange(); pre.selectNodeContents(el); pre.setEnd(range.startContainer, range.startOffset);
          const post = range.cloneRange(); post.selectNodeContents(el); post.setEnd(range.endContainer, range.endOffset);
          return { start: pre.toString().length, end: post.toString().length };
        };
        const setSelection = (el, start, end = start) => {
          if (isInput(el)) return el.setSelectionRange(start, end);
          const textNode = el.firstChild || el.appendChild(document.createTextNode(getText(el)));
          const range = document.createRange();
          range.setStart(textNode, Math.max(0, Math.min(start, textNode.textContent.length)));
          range.setEnd(textNode, Math.max(0, Math.min(end, textNode.textContent.length)));
          const selection = window.getSelection(); selection.removeAllRanges(); selection.addRange(range);
        };

        const activateTarget = (target) => { if (!target || activeTarget === target) return; if (activeTarget) activeTarget.classList.remove('is-active-target'); activeTarget = target; target.classList.add('is-active-target'); if (isInput(target) && document.activeElement !== target) target.focus({ preventScroll: true }); initialValueOnFocus = getText(target); };
        const blurActiveTarget = () => { if (!activeTarget) return; activeTarget.classList.remove('is-active-target'); if (document.activeElement instanceof HTMLElement) document.activeElement.blur(); activeTarget = null; };
        const insertIntoTarget = (text) => { if (!activeTarget) return; const value = getText(activeTarget); const { start, end } = getSelection(activeTarget); setText(activeTarget, value.slice(0, start) + text + value.slice(end)); setSelection(activeTarget, start + text.length); resetClearStage(); };
        const deleteBackward = () => { if (!activeTarget) return; const value = getText(activeTarget); const { start, end } = getSelection(activeTarget); if (start !== end) { setText(activeTarget, value.slice(0, start) + value.slice(end)); setSelection(activeTarget, start); } else if (start > 0) { setText(activeTarget, value.slice(0, start - 1) + value.slice(start)); setSelection(activeTarget, start - 1); } resetClearStage(); };
        const moveCursor = (delta) => { if (!activeTarget) return; const { start, end } = getSelection(activeTarget); const base = delta < 0 ? start : end; setSelection(activeTarget, Math.max(0, Math.min(base + delta, getText(activeTarget).length))); };
        const toNumericOrZero = (rawValue) => { const value = String(rawValue ?? '').trim(); if (!value) return 0; const numeric = Number(value); if (!Number.isFinite(numeric)) throw new Error('NON_NUMERIC'); return numeric; };

        const tokenize = (source) => { const tokens = []; const text = String(source ?? ''); let index = 0; while (index < text.length) { const char = text[index]; if (/\s/.test(char)) { index += 1; continue; } if ((char >= '0' && char <= '9') || char === '.') { let end = index; while (end < text.length && /[0-9.]/.test(text[end])) end += 1; const literal = text.slice(index, end); if ((literal.match(/\./g) || []).length > 1 || literal === '.') throw new SyntaxError('Invalid number'); tokens.push({ type: 'number', value: Number(literal) }); index = end; continue; } const normalized = char === '−' ? '-' : char; if ('+-*/^'.includes(normalized)) { tokens.push({ type: 'operator', value: normalized }); index += 1; continue; } if (normalized === '(' || normalized === ')') { tokens.push({ type: 'paren', value: normalized }); index += 1; continue; } if (normalized === ',') { tokens.push({ type: 'comma', value: ',' }); index += 1; continue; } if (normalized === '√') { tokens.push({ type: 'root', value: '√' }); index += 1; continue; } if (/[A-Za-z]/.test(normalized)) { const upper = normalized.toUpperCase(); if (!ALL_LETTERS.includes(upper)) throw new SyntaxError('Unknown variable'); tokens.push({ type: 'variable', value: upper }); index += 1; continue; } throw new SyntaxError('Unexpected token'); } return tokens; };
        const parse = (tokens) => { let cursor = 0; const peek = () => tokens[cursor]; const consume = () => tokens[cursor++]; const primary = () => { const token = peek(); if (!token) throw new SyntaxError('Unexpected end'); if (token.type === 'number') return consume(), { type: 'number', value: token.value }; if (token.type === 'variable') return consume(), { type: 'variable', name: token.value }; if (token.type === 'paren' && token.value === '(') { consume(); const expr = expression(); const close = consume(); if (!close || close.type !== 'paren' || close.value !== ')') throw new SyntaxError('Missing close paren'); return expr; } if (token.type === 'root') { consume(); const open = consume(); if (!open || open.type !== 'paren' || open.value !== '(') throw new SyntaxError('Root call requires parenthesis'); const first = expression(); if (peek()?.type === 'comma') { consume(); const second = expression(); const close = consume(); if (!close || close.type !== 'paren' || close.value !== ')') throw new SyntaxError('Missing close paren'); return { type: 'root', degree: first, radicand: second }; } const close = consume(); if (!close || close.type !== 'paren' || close.value !== ')') throw new SyntaxError('Missing close paren'); return { type: 'root', degree: null, radicand: first }; } throw new SyntaxError('Unexpected token'); }; const unary = () => peek()?.type === 'operator' && '+-'.includes(peek().value) ? { type: 'unary', operator: consume().value, argument: unary() } : primary(); const power = () => { let left = unary(); while (peek()?.type === 'operator' && peek().value === '^') left = { type: 'binary', operator: consume().value, left, right: unary() }; return left; }; const term = () => { let left = power(); while (peek()?.type === 'operator' && '*/'.includes(peek().value)) left = { type: 'binary', operator: consume().value, left, right: power() }; return left; }; const expression = () => { let left = term(); while (peek()?.type === 'operator' && '+-'.includes(peek().value)) left = { type: 'binary', operator: consume().value, left, right: term() }; return left; }; const ast = expression(); if (cursor < tokens.length) throw new SyntaxError('Trailing tokens'); return ast; };
        const evaluateAst = (node, scope) => { if (node.type === 'number') return node.value; if (node.type === 'variable') return scope[node.name] ?? 0; if (node.type === 'unary') return node.operator === '-' ? -evaluateAst(node.argument, scope) : evaluateAst(node.argument, scope); if (node.type === 'binary') { const left = evaluateAst(node.left, scope); const right = evaluateAst(node.right, scope); if (node.operator === '+') return left + right; if (node.operator === '-') return left - right; if (node.operator === '*') return left * right; if (node.operator === '/') { if (right === 0) throw new Error('DIV_0'); return left / right; } return left ** right; } const radicand = evaluateAst(node.radicand, scope); if (!node.degree) return Math.sqrt(radicand); const degree = evaluateAst(node.degree, scope); if (degree === 0) throw new Error('DIV_0'); return radicand ** (1 / degree); };
        const mapErrorToCellText = (error) => error instanceof SyntaxError ? 'Syntax' : (error?.message === 'DIV_0' ? 'DIV/0' : 'Error');
        const formatNumber = (value) => Number.isFinite(value) ? (Number.isInteger(value) ? String(value) : value.toFixed(8).replace(/\.?0+$/, '')) : 'Error';
        const sheetIsBlank = (sheet) => !sheet.formulaCanonical.trim() && Object.values(sheet.constants).every((v) => !String(v).trim()) && sheet.rows.every((row) => KEY_ORDER.every((k) => !String(row[k] || '').trim()) && !String(row.Result || '').trim());
        const applyStat = (values, statName) => !values.length ? '—' : (statName === 'Sum' ? formatNumber(values.reduce((a, b) => a + b, 0)) : statName === 'Avg' ? formatNumber(values.reduce((a, b) => a + b, 0) / values.length) : statName === 'Min' ? formatNumber(Math.min(...values)) : statName === 'Max' ? formatNumber(Math.max(...values)) : statName === 'Count' ? String(values.length) : '—');

        const recomputeStatsFromSheet = (sheet) => { statCells.forEach((cell, index) => { const output = cell.querySelector('output'); const statName = sheet.stats[index] || '--'; if (statName === '--') { output.textContent = '—'; return; } const values = sheet.rows.map((row) => index < 4 ? String(row[KEY_ORDER[index]] || '').trim() : String(row.Result || '').trim()).filter((v) => v !== '').map(Number).filter((n) => Number.isFinite(n)); output.textContent = applyStat(values, statName); }); };
        const persistFromDom = () => {
          const sheet = state.sheets[state.currentSheetIndex];
          sheet.title = titleLine.textContent.trim() || 'Untitled';
          sheet.name = sheetNameLine.textContent.trim() || `Sheet ${state.currentSheetIndex + 1}`;
          sheet.formulaCanonical = displayToCanonical(formulaInput.value, sheet);
          [...headerNameEls, ...constNameEls].forEach((el, idx) => { const key = idx < 4 ? KEY_ORDER[idx] : CONST_ORDER[idx - 4]; sheet.names[key] = (el.textContent || '').trim(); });
          constantInputs.forEach((input, idx) => { sheet.constants[CONST_ORDER[idx]] = input.value; });
          rowBindings.forEach((row, ri) => { KEY_ORDER.forEach((key, ci) => { sheet.rows[ri][key] = row.inputs[ci].value; }); sheet.rows[ri].Result = row.resultCell.textContent || ''; });
          statCells.forEach((cell, idx) => { const select = cell.querySelector('select'); sheet.stats[idx] = select?.value || '--'; });
          scheduleSave();
        };
        const renderSheet = () => {
          const sheet = state.sheets[state.currentSheetIndex];
          const clean = sanitizeNameMap(sheet);
          titleLine.textContent = sheet.title;
          sheetNameLine.textContent = sheet.name;
          sheetIndexEl.textContent = `${state.currentSheetIndex + 1}/${state.sheets.length}`;
          formulaInput.value = canonicalToDisplay(sheet.formulaCanonical, sheet);
          toggleButton.innerHTML = state.formulaMode === 'letter' ? '<strong>A</strong> / Name' : 'A / <strong>Name</strong>';
          KEY_ORDER.forEach((key, idx) => { headerLetterEls[idx].textContent = key; headerNameEls[idx].textContent = clean[key]; headerNameEls[idx].style.display = state.formulaMode === 'letter' ? 'none' : ''; });
          CONST_ORDER.forEach((key, idx) => { constLetterEls[idx].textContent = key; constNameEls[idx].textContent = clean[key]; constNameEls[idx].style.display = state.formulaMode === 'letter' ? 'none' : ''; constantInputs[idx].value = sheet.constants[key] || ''; });
          rowBindings.forEach((row, ri) => { KEY_ORDER.forEach((key, ci) => { row.inputs[ci].value = sheet.rows[ri][key] || ''; }); row.resultCell.textContent = sheet.rows[ri].Result || ''; });
          statCells.forEach((cell, idx) => { const select = cell.querySelector('select'); if (select) select.value = sheet.stats[idx] || '--'; });
          recomputeStatsFromSheet(sheet);
        };

        const computeAllRows = () => {
          persistFromDom();
          const sheet = state.sheets[state.currentSheetIndex];
          let ast;
          try { ast = parse(tokenize(sheet.formulaCanonical)); } catch (error) { sheet.rows.forEach((row) => { row.Result = mapErrorToCellText(error); }); renderSheet(); return; }
          let constants;
          try { constants = Object.fromEntries(CONST_ORDER.map((k) => [k, toNumericOrZero(sheet.constants[k])])); } catch (error) { sheet.rows.forEach((row) => { row.Result = mapErrorToCellText(error); }); renderSheet(); return; }
          sheet.rows.forEach((row) => {
            try { const scope = { ...constants, ...Object.fromEntries(KEY_ORDER.map((k) => [k, toNumericOrZero(row[k])])) }; row.Result = formatNumber(evaluateAst(ast, scope)); }
            catch (error) { row.Result = mapErrorToCellText(error); }
          });
          renderSheet();
          scheduleSave();
        };

        const deleteBlankDynamicCurrentSheet = () => {
          const idx = state.currentSheetIndex;
          if (idx < 2 || state.sheets.length <= 2) return;
          if (sheetIsBlank(state.sheets[idx])) { state.sheets.splice(idx, 1); if (state.currentSheetIndex >= state.sheets.length) state.currentSheetIndex = 0; }
        };
        const nav = (dir) => { persistFromDom(); const wasLast = state.currentSheetIndex === state.sheets.length - 1; deleteBlankDynamicCurrentSheet(); if (dir > 0 && wasLast) { state.sheets.push(makeSheet(state.sheets.length)); state.currentSheetIndex = state.sheets.length - 1; } else { state.currentSheetIndex = (state.currentSheetIndex + dir + state.sheets.length) % state.sheets.length; } renderSheet(); resetClearStage(); scheduleSave(); };

        const clearAction = () => {
          persistFromDom();
          const sheet = state.sheets[state.currentSheetIndex];
          if (state.clearStage === 0) { if (activeTarget) setText(activeTarget, ''); }
          else if (state.clearStage === 1) { const row = activeTarget?.closest?.('tr'); const rowIndex = dataRows.indexOf(row); if (rowIndex >= 0) sheet.rows[rowIndex] = { A: '', B: '', C: '', D: '', Result: '' }; }
          else if (state.clearStage === 2) { sheet.constants = { V: '', W: '', X: '', Y: '', Z: '' }; sheet.formulaCanonical = ''; sheet.rows = makeBlankRows(); }
          else { state.sheets = [makeSheet(0), makeSheet(1)]; state.currentSheetIndex = 0; }
          renderSheet();
          advanceClearStage();
          scheduleSave();
        };

        const numericTargets = [...constantInputs, formulaInput, ...cellInputs];
        const titleFields = [titleLine, sheetNameLine, ...headerNameEls, ...constNameEls].filter(Boolean);
        const editableTargets = [...numericTargets, ...titleFields];
        numericTargets.forEach((target) => { target.setAttribute('inputmode', 'none'); ['focus', 'pointerdown', 'click'].forEach((eventName) => target.addEventListener(eventName, () => activateTarget(target))); target.addEventListener('input', () => { resetClearStage(); persistFromDom(); }); });
        titleFields.forEach((target) => { ['focus', 'pointerup', 'click'].forEach((eventName) => target.addEventListener(eventName, () => activateTarget(target))); target.addEventListener('input', () => { resetClearStage(); persistFromDom(); }); });

        const handleKeyPress = (key) => {
          const label = key.textContent.trim();
          if (key === minimizeKey) return keypad.classList.toggle('minimized');
          if (key === undoKey) { if (!activeTarget) return; setText(activeTarget, initialValueOnFocus); setSelection(activeTarget, getText(activeTarget).length); resetClearStage(); return; }
          if (key === backspaceKey) return deleteBackward();
          if (key === leftKey) return moveCursor(-1);
          if (key === rightKey) return moveCursor(1);
          if (key === resultKey) { blurActiveTarget(); computeAllRows(); resetClearStage(); return; }
          if (label === '⌨︎') return;
          insertIntoTarget(label === '−' ? '-' : label);
          persistFromDom();
        };

        keys.forEach((key) => { let pointerTriggered = false; key.addEventListener('pointerdown', (event) => { event.preventDefault(); pointerTriggered = true; handleKeyPress(key); }); key.addEventListener('click', (event) => { event.preventDefault(); if (pointerTriggered) { pointerTriggered = false; return; } handleKeyPress(key); }); });
        sheetNavButtons[0]?.addEventListener('click', () => { blurActiveTarget(); nav(-1); });
        sheetNavButtons[1]?.addEventListener('click', () => { blurActiveTarget(); nav(1); });
        toggleButton?.addEventListener('click', () => { persistFromDom(); state.formulaMode = state.formulaMode === 'letter' ? 'name' : 'letter'; renderSheet(); scheduleSave(); resetClearStage(); });
        clearButton?.addEventListener('click', (event) => { event.preventDefault(); clearAction(); });
        if (resultHeaderTrigger) {
          let pointer = false;
          resultHeaderTrigger.addEventListener('pointerdown', (event) => { event.preventDefault(); pointer = true; blurActiveTarget(); computeAllRows(); resetClearStage(); });
          resultHeaderTrigger.addEventListener('click', (event) => { event.preventDefault(); if (pointer) { pointer = false; return; } blurActiveTarget(); computeAllRows(); resetClearStage(); });
          resultHeaderTrigger.addEventListener('keydown', (event) => { if (!['Enter', ' '].includes(event.key)) return; event.preventDefault(); blurActiveTarget(); computeAllRows(); resetClearStage(); });
        }
        editableTargets.forEach((target) => target.addEventListener('blur', () => { if (activeTarget === target) { target.classList.remove('is-active-target'); activeTarget = null; } persistFromDom(); }));
        statCells.forEach((cell, idx) => { const select = cell.querySelector('select'); select?.addEventListener('change', () => { state.sheets[state.currentSheetIndex].stats[idx] = select.value; scheduleSave(); resetClearStage(); }); });
        document.addEventListener('keydown', (event) => { if (event.key !== 'Enter') return; if (!activeTarget || !editableTargets.includes(activeTarget)) return; event.preventDefault(); blurActiveTarget(); computeAllRows(); resetClearStage(); });

        (async () => {
          const saved = await asyncStorage.get();
          if (saved?.sheets?.length) {
            state.sheets = saved.sheets;
            state.currentSheetIndex = Math.max(0, Math.min(saved.currentSheetIndex || 0, state.sheets.length - 1));
            state.formulaMode = saved.formulaMode === 'letter' ? 'letter' : 'name';
          }
          while (state.sheets.length < 2) state.sheets.push(makeSheet(state.sheets.length));
          renderSheet();
          resetClearStage();
        })();
      })();
    </script>
  </body>
</html>
