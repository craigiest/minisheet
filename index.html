<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <title>MiniSheet</title>
    <style>
      :root {
        --bg: #ececef;
        --panel: #f3f3f5;
        --line: #d5d5da;
        --text: #1d2029;
        --active: #305596;
        --active-soft: #6aa8f1;
        --nav-h: 56px;
        --const-h: 86px;
        --formula-h: 56px;
        --keypad-h: 238px;
        --keypad-min-h: 56px;
        --keypad-active-h: var(--keypad-h);
        --keypad-bg: #7082a7;
      }

      body.keypad-is-minimized {
        --keypad-active-h: var(--keypad-min-h);
      }

      * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
      }

      button,
      input,
      select {
        font: inherit;
      }

      button,
      .key,
      .arrow,
      .sheet-title,
      .cell-input,
      .formula-input,
      .const-cell input,
      select {
        touch-action: manipulation;
      }

      html,
      body,
      .grid-wrap,
      .constants-strip,
      .formula-strip,
      .keypad {
        touch-action: manipulation;
      }

      .nav {
        position: fixed;
        top: env(safe-area-inset-top);
        left: 0;
        right: 0;
        height: var(--nav-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 34px minmax(0,1fr) 34px;
        gap: 6px;
        align-items: center;
        padding: 6px 8px;
        z-index: 60;
        isolation: isolate;
      }

      .arrow {
        width: 34px;
        height: 30px;
        border: 0;
        background: transparent;
        font-size: 18px;
        position: relative;
        z-index: 3;
      }

      .title-block {
        position: relative;
        z-index: 1;
        min-width: 0;
        overflow: hidden;
        pointer-events: none;
      }

      .sheet-line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        min-width: 0;
        width: 100%;
      }

      .sheet-index {
        font-size: 12px;
        font-weight: 600;
        white-space: nowrap;
      }

      .sheet-title {
        font-size: 16px;
        pointer-events: auto;
        line-height: 1.1;
        color: var(--text);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1;
        min-width: 0;
      }

      .constants-strip {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h));
        left: 0;
        right: 0;
        height: var(--const-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 52px repeat(5, minmax(0, 1fr));
        z-index: 50;
      }

      .clear-cell,
      .const-cell {
        border-right: 1px solid var(--line);
        padding: 6px 4px;
        display: grid;
        gap: 4px;
        align-content: center;
      }

      .clear-cell {
        place-items: center;
      }

      .key-active {
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        background: var(--active);
        color: #fff;
        display: grid;
        place-items: center;
        width: 42px;
        height: 42px;
        font-size: 16px;
      }

      .const-top {
        border-radius: 8px;
        background: #f1f1f3;
        color: var(--text);
        min-height: 34px;
        display: grid;
        align-content: center;
        justify-items: center;
        padding: 4px;
      }

      .const-top .letter {
        font-size: 12px;
        line-height: 1;
        font-weight: 700;
      }

      .const-top .name {
        font-size: 11px;
        font-weight: 400;
      }

      .const-cell input {
        width: 100%;
        height: 30px;
        border: 1px solid #c7c7ce;
        border-radius: 7px;
        background: #efefef;
        font-size: 14px;
        padding: 2px 6px;
      }

      .formula-strip {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h) + var(--const-h));
        left: 0;
        right: 0;
        height: var(--formula-h);
        background: var(--panel);
        border-bottom: 1px solid var(--line);
        display: grid;
        grid-template-columns: 30px 1fr auto;
        align-items: center;
        gap: 6px;
        padding: 6px 8px;
        z-index: 49;
      }

      .fx-eq {
        font-size: 26px;
        font-weight: 700;
        text-align: center;
      }

      .formula-input {
        width: 100%;
        min-width: 0;
        height: 42px;
        border: 2px solid #c7c7ce;
        border-radius: 10px;
        box-shadow: none;
        background: #f0f0f2;
        font-size: 14px;
        padding: 6px 10px;
      }

      .formula-input.is-active-target {
        border-color: var(--active-soft);
        box-shadow: 0 0 0 1px rgba(106, 168, 241, 0.35) inset;
      }

      .toggle {
        font-size: 12px;
        white-space: nowrap;
      }

      .grid-wrap {
        position: fixed;
        top: calc(env(safe-area-inset-top) + var(--nav-h) + var(--const-h) + var(--formula-h));
        left: 0;
        right: 0;
        bottom: calc(env(safe-area-inset-bottom) + var(--keypad-active-h));
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        background: #f7f7f8;
        z-index: 20;
      }

      table {
        border-collapse: separate;
        border-spacing: 0;
        width: 100%;
        table-layout: fixed;
      }

      col.col-num { width: 10%; }
      col.col-main { width: 17%; }
      col.col-result { width: 22%; }

      th,
      td {
        border-right: 1px solid var(--line);
        border-bottom: 1px solid var(--line);
        background: #f1f1f3;
      }

      th:last-child,
      td:last-child {
        border-right: 0;
      }

      thead th {
        position: sticky;
        top: 0;
        z-index: 7;
        height: 48px;
      }

      tbody td {
        height: 24px;
      }

      .num-head,
      .num {
        position: sticky;
        left: 0;
        background: #f1f1f3;
        z-index: 8;
        font-size: 15px;
      }

      .num-head {
        text-align: center;
      }

      .num {
        text-align: right;
        padding-right: 6px;
      }

      .num-head {
        font-size: 17px;
        font-weight: 700;
      }

      .col-head {
        padding: 4px;
        background: #ececef;
      }

      .head-pill {
        background: #f1f1f3;
        color: var(--text);
        border-radius: 8px;
        min-height: 38px;
        display: grid;
        align-content: center;
        justify-items: center;
      }

      body.formula-entry-active .col-head:not(.result-head) .head-pill,
      body.formula-entry-active .const-top {
        background: var(--active);
        color: #fff;
      }

      .head-pill .letter { font-size: 14px; font-weight: 700; }
      .head-pill .name { font-size: 11px; font-weight: 400; }

      .result-head .head-pill {
        background: var(--active);
        color: #fff;
        min-height: 38px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .result-head .head-pill .name {
        display: none;
      }

      body.formula-mode-name .head-pill .letter,
      body.formula-mode-name .const-top .letter {
        font-weight: 400;
      }

      body.formula-mode-name .head-pill .name,
      body.formula-mode-name .const-top .name {
        font-weight: 700;
      }

      .result-head,
      .result-cell {
        position: sticky;
        right: 0;
        z-index: 6;
      }

      .result-cell {
        text-align: right;
        padding-right: 8px;
      }

      .result-head { z-index: 9; }

      tfoot td {
        position: sticky;
        bottom: 0;
        z-index: 10;
        background: var(--panel);
        border-top: 2px solid #a4acb8;
        padding: 4px;
        height: 58px;
      }

      tfoot {
        box-shadow: inset 0 2px 0 #a4acb8;
      }

      tfoot .num {
        font-weight: 700;
        font-size: 18px;
      }

      .stat-cell {
        border: 0;
        border-radius: 0;
        background: transparent;
        height: 48px;
        display: grid;
        grid-template-rows: 1fr 1fr;
        align-items: center;
        padding: 0 4px;
      }

      .stat-cell select {
        width: 100%;
        height: 22px;
        line-height: 22px;
        border: 1px solid #d2d7e2;
        border-radius: 6px;
        background: #f6f8fb;
        color: #2f5f9f;
        font-size: 12px;
        padding: 0 4px;
      }

      .stat-cell output {
        width: 100%;
        height: 22px;
        display: grid;
        align-items: center;
        justify-items: end;
        text-align: right;
        border: 0;
        background: transparent;
        color: #596275;
        font-size: 15px;
        font-weight: 700;
      }

      .keypad {
        position: fixed;
        left: 0;
        right: 0;
        bottom: env(safe-area-inset-bottom);
        height: var(--keypad-h);
        padding: 6px;
        background: var(--keypad-bg);
        border-top: 1px solid #5d6f97;
        z-index: 41;
        transition: height 0.2s ease;
      }

      .keys {
        height: 100%;
        display: grid;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        grid-template-rows: repeat(6, minmax(0, 1fr));
        gap: 6px;
      }

      .key {
        appearance: none;
        -webkit-appearance: none;
        border: 0;
        border-radius: 8px;
        background: var(--active);
        box-shadow: none;
        color: #fff;
        font-size: 18px;
        outline: none;
      }

      .key:focus-visible {
        outline: 2px solid #f0f3fa;
        outline-offset: 2px;
      }

      .key.light {
        background: transparent;
        color: #f0f3fa;
        border: 1px solid transparent;
      }


      .key.is-inactive,
      .key.light.is-inactive {
        background: var(--keypad-bg);
        color: #d8deea;
        border-color: transparent;
      }

      .key-active.is-inactive {
        background: var(--panel);
        color: #8a94a8;
        border-color: transparent;
      }

      .key-active.is-danger {
        background: #b43e4c;
        color: #fff;
      }

      .keypad.minimized {
        height: var(--keypad-min-h);
      }

      .keypad.minimized .keys {
        grid-template-rows: 1fr;
      }

      .keypad.minimized .key:nth-child(n + 7) {
        display: none;
      }

      .editable-cell {
        padding: 0;
      }

      .cell-input {
        width: 100%;
        height: 100%;
        border: 0;
        background: transparent;
        padding: 0 8px;
        text-align: right;
        font-size: 15px;
      }

      .is-active-target {
        outline: 2px solid var(--active-soft);
        outline-offset: -2px;
      }


      @media (pointer: coarse) {
        .cell-input,
        .formula-input,
        .const-cell input {
          font-size: 16px;
        }
      }

    </style>
  </head>
  <body>
    <header class="nav">
      <button class="arrow" aria-label="Previous sheet">◀</button>
      <div class="title-block">
        <div class="sheet-line"><span class="sheet-title" contenteditable="true" role="textbox" aria-label="Sheet title">Proportion: A/B = C/Result</span><span class="sheet-index">1/2</span></div>
      </div>
      <button class="arrow" aria-label="Next sheet">▶</button>
    </header>

    <section class="constants-strip" aria-label="Constants strip">
      <div class="clear-cell"><button class="key-active" aria-label="Clear">C</button></div>
      <div class="const-cell"><div class="const-top"><div class="letter">V</div><div class="name">const1</div></div><input inputmode="none" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">W</div><div class="name">const2</div></div><input inputmode="none" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">X</div><div class="name">const3</div></div><input inputmode="none" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">Y</div><div class="name">const4</div></div><input inputmode="none" value="" /></div>
      <div class="const-cell"><div class="const-top"><div class="letter">Z</div><div class="name">const5</div></div><input inputmode="none" value="" /></div>
    </section>

    <section class="formula-strip" aria-label="Formula editor strip">
      <div class="fx-eq">=</div>
      <input class="formula-input" value="(B*C)/A" aria-label="Formula editor" />
      <button class="toggle" type="button" aria-label="Toggle formula labels">A / <strong>Name</strong></button>
    </section>

    <main class="grid-wrap" aria-label="Grid area">
      <table>
        <colgroup>
          <col class="col-num" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-main" />
          <col class="col-result" />
        </colgroup>
        <thead>
          <tr>
            <th class="num-head">#</th>
            <th class="col-head"><div class="head-pill"><div class="letter">A</div><div class="name">value1</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">B</div><div class="name">value2</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">C</div><div class="name">value3</div></div></th>
            <th class="col-head"><div class="head-pill"><div class="letter">D</div><div class="name">unused</div></div></th>
            <th class="col-head result-head" role="button" tabindex="0" aria-label="Compute results"><div class="head-pill"><div class="letter">Result</div><div class="name"></div></div></th>
          </tr>
        </thead>
        <tbody>
          <tr><td class="num">1</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">2</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">3</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">4</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">5</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">6</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">7</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">8</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">9</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">10</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">11</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">12</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">13</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">14</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">15</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">16</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">17</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">18</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">19</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
          <tr><td class="num">20</td><td></td><td></td><td></td><td></td><td class="result-cell"></td></tr>
        </tbody>
        <tfoot>
          <tr>
            <td class="num">#</td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
            <td><div class="stat-cell"><select><option>--</option><option>Sum</option><option>Avg</option><option>Min</option><option>Max</option><option>Count</option></select><output>—</output></div></td>
          </tr>
        </tfoot>
      </table>
    </main>

    <section class="keypad" aria-label="Bottom keypad">
      <div class="keys">
        <button class="key">↺</button><button class="key">⌨︎</button><button class="key">↕</button><button class="key">:</button><button class="key">√</button><button class="key">⌫</button>
        <button class="key light">&lt;</button><button class="key light">&gt;</button><button class="key">(</button><button class="key">)</button><button class="key">^</button><button class="key">/</button>
        <button class="key light">IF</button><button class="key light">AVG</button><button class="key">7</button><button class="key">8</button><button class="key">9</button><button class="key">*</button>
        <button class="key light">AND</button><button class="key light">SUM</button><button class="key">4</button><button class="key">5</button><button class="key">6</button><button class="key">−</button>
        <button class="key light">OR</button><button class="key light">MAX</button><button class="key">1</button><button class="key">2</button><button class="key">3</button><button class="key">+</button>
        <button class="key light">NOT</button><button class="key light">MIN</button><button class="key">0</button><button class="key">.</button><button class="key">,</button><button class="key enter">=</button>
      </div>
    </section>

    <script>
      (() => {
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (event) => {
          const now = Date.now();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        }, { passive: false });

        document.addEventListener('gesturestart', (event) => {
          event.preventDefault();
        }, { passive: false });

        const ROW_COUNT = 20;
        const KEY_ORDER = ['A', 'B', 'C', 'D'];
        const CONST_ORDER = ['V', 'W', 'X', 'Y', 'Z'];
        const ALL_LETTERS = [...KEY_ORDER, ...CONST_ORDER];
        const STORAGE_KEY = 'minisheet-v2';

        const keypad = document.querySelector('.keypad');
        const keys = [...document.querySelectorAll('.keypad .key')];
        const minimizeKey = keys.find((key) => key.textContent.trim() === '↕');
        const undoKey = keys.find((key) => key.textContent.trim() === '↺');
        const backspaceKey = keys.find((key) => key.textContent.trim() === '⌫');
        const leftKey = keys.find((key) => key.textContent.trim() === '<');
        const rightKey = keys.find((key) => key.textContent.trim() === '>');
        const resultKey = keys.find((key) => key.textContent.trim() === '=');
        const sheetNavButtons = [...document.querySelectorAll('.nav .arrow')];
        const sheetTitleEl = document.querySelector('.sheet-title');
        const resultHeaderTrigger = document.querySelector('th.result-head');
        const clearButton = document.querySelector('.key-active');
        const toggleButton = document.querySelector('.toggle');
        const titleLine = document.querySelector('.title-line') || sheetTitleEl;
        const sheetIndexEl = document.querySelector('.sheet-index');
        const sheetNameLine = document.querySelector('.sheet-name');
        const formulaInput = document.querySelector('.formula-input');
        const constantInputs = [...document.querySelectorAll('.const-cell input')];
        const constTopEls = [...document.querySelectorAll('.const-top')];
        const dataRows = [...document.querySelectorAll('tbody tr')];
        const statCells = [...document.querySelectorAll('tfoot .stat-cell')];
        const headerPills = [...document.querySelectorAll('thead .head-pill')];
        const getKeyLabel = (key) => key?.textContent.trim() || '';
        const NUMBER_ENTRY_KEY_LABELS = new Set(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '−', '↺', '⌫', '=', '↕']);
        const FORMULA_ENTRY_KEY_LABELS = new Set(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '−', '+', '*', '/', '^', '(', ')', ',', ':', '⌫', '↺', '↕', '⌨︎']);

        const asyncStorage = {
          async get() {
            await Promise.resolve();
            const raw = localStorage.getItem(STORAGE_KEY);
            return raw ? JSON.parse(raw) : null;
          },
          async set(value) {
            await Promise.resolve();
            localStorage.setItem(STORAGE_KEY, JSON.stringify(value));
          }
        };

        const sheetTemplate = (idx) => {
          if (idx === 0) {
            return {
              title: '* for US-->metric, / for metric-->US',
              formula: 'A*V',
              names: { V: 'in/cm', W: 'ft/m', X: 'mi/km', Y: 'oz/g', Z: 'lb/kg' },
              constants: { V: '2.54', W: '0.3048', X: '1.60934', Y: '28.3495', Z: '0.453592' }
            };
          }
          if (idx === 1) return { title: 'Proportion: A/B = C/Result', formula: '(B*C)/A' };
          return { title: 'New Sheet', formula: '' };
        };

        const baseNames = { A: 'value1', B: 'value2', C: 'value3', D: 'unused', V: 'const1', W: 'const2', X: 'const3', Y: 'const4', Z: 'const5' };
        const makeBlankRows = () => Array.from({ length: ROW_COUNT }, () => ({ A: '', B: '', C: '', D: '', Result: '' }));
        const makeSheet = (idx) => {
          const t = sheetTemplate(idx);
          return {
            title: t.title,
            formulaCanonical: t.formula,
            names: { ...baseNames, ...(t.names || {}) },
            constants: { V: '', W: '', X: '', Y: '', Z: '', ...(t.constants || {}) },
            rows: makeBlankRows(),
            stats: ['--', '--', '--', '--', '--']
          };
        };

        const hydrateSheet = (rawSheet, idx) => {
          const fallback = makeSheet(idx);
          const sheetObj = (rawSheet && typeof rawSheet === 'object') ? rawSheet : {};
          const { name: _legacyNameField, ...sheet } = sheetObj;
          const legacyTitle = typeof sheet.title === 'string' ? sheet.title.trim() : '';
          const legacyName = typeof _legacyNameField === 'string' ? _legacyNameField.trim() : '';
          const titleFromLegacyComposite = legacyTitle.includes('|') ? legacyTitle.split('|')[0].trim() : legacyTitle;
          return {
            ...fallback,
            ...sheet,
            title: titleFromLegacyComposite || legacyName || fallback.title,
            formulaCanonical: typeof sheet.formulaCanonical === 'string' ? sheet.formulaCanonical : fallback.formulaCanonical,
            names: { ...fallback.names, ...(sheet.names || {}) },
            constants: { ...fallback.constants, ...(sheet.constants || {}) },
            rows: Array.isArray(sheet.rows) ? sheet.rows.map((row) => ({ A: '', B: '', C: '', D: '', Result: '', ...(row || {}) })) : fallback.rows,
            stats: Array.isArray(sheet.stats) ? sheet.stats.slice(0, 5) : fallback.stats
          };
        };

        const state = { sheets: [makeSheet(0), makeSheet(1), makeSheet(2)], currentSheetIndex: 0, formulaMode: 'name', clearStage: 0, acConfirmPresses: 0 };

        let saveTimer = null;
        const scheduleSave = () => {
          if (saveTimer) clearTimeout(saveTimer);
          saveTimer = setTimeout(() => asyncStorage.set({ sheets: state.sheets, currentSheetIndex: state.currentSheetIndex, formulaMode: state.formulaMode }), 250);
        };

        dataRows.forEach((row) => {
          [...row.children].forEach((cell, index) => {
            if (index === 0 || cell.classList.contains('result-cell')) return;
            cell.classList.add('editable-cell');
            cell.innerHTML = '<input class="cell-input" inputmode="none" value="" aria-label="Grid cell value" />';
          });
        });

        const cellInputs = [...document.querySelectorAll('.cell-input')];
        const rowBindings = dataRows.map((row) => ({ inputs: [...row.querySelectorAll('.cell-input')], resultCell: row.querySelector('.result-cell') }));
        const numberEntryTargets = new Set([...constantInputs, ...cellInputs]);
        const isNumberEntryContext = () => !!activeTarget && numberEntryTargets.has(activeTarget);
        const isFormulaEntryContext = () => activeTarget === formulaInput;
        const getInputContext = () => isNumberEntryContext() ? 'number' : (isFormulaEntryContext() ? 'formula' : 'default');
        const isKeyEnabled = (key) => {
          const label = getKeyLabel(key);
          const context = getInputContext();
          if (context === 'number') return NUMBER_ENTRY_KEY_LABELS.has(label);
          if (context === 'formula') return FORMULA_ENTRY_KEY_LABELS.has(label);
          return true;
        };
        const updateKeyAvailability = () => {
          keys.forEach((key) => {
            const enabled = isKeyEnabled(key);
            key.disabled = !enabled;
            key.classList.toggle('is-inactive', !enabled);
            key.setAttribute('aria-disabled', enabled ? 'false' : 'true');
          });
          document.body.classList.toggle('formula-entry-active', isFormulaEntryContext());
          const clearEnabled = !!activeTarget || state.clearStage > 0;
          clearButton?.classList.toggle('is-inactive', !clearEnabled);
          clearButton?.setAttribute('aria-disabled', clearEnabled ? 'false' : 'true');
        };
        const headerNameEls = headerPills.slice(0, 4).map((pill) => pill.querySelector('.name'));
        const headerLetterEls = headerPills.slice(0, 4).map((pill) => pill.querySelector('.letter'));
        const constNameEls = constTopEls.map((pill) => pill.querySelector('.name'));
        const constLetterEls = constTopEls.map((pill) => pill.querySelector('.letter'));

        [...headerNameEls, ...constNameEls].forEach((el) => {
          if (!el) return;
          el.setAttribute('contenteditable', 'true');
          el.setAttribute('role', 'textbox');
        });

        let activeTarget = null;
        let initialValueOnFocus = '';

        const CLEAR_STAGE_META = [
          { label: 'C', ariaLabel: 'Clear selected item', danger: false },
          { label: '#C', ariaLabel: 'Clear all grid values', danger: false },
          { label: 'CC', ariaLabel: 'Clear constants', danger: false },
          { label: 'AC', ariaLabel: 'Clear entire sheet', danger: false },
          { label: 'Rst', ariaLabel: 'Reset all sheets to defaults', danger: true }
        ];
        const syncClearButtonUi = () => {
          if (!clearButton) return;
          const meta = CLEAR_STAGE_META[state.clearStage] || CLEAR_STAGE_META[0];
          clearButton.textContent = meta.label;
          clearButton.setAttribute('aria-label', meta.ariaLabel);
          clearButton.classList.toggle('is-danger', !!meta.danger);
        };
        const setClearStage = (nextStage) => {
          state.clearStage = Math.max(0, Math.min(CLEAR_STAGE_META.length - 1, nextStage));
          if (state.clearStage < 3) state.acConfirmPresses = 0;
          syncClearButtonUi();
          updateKeyAvailability();
        };
        const resetClearStage = () => setClearStage(0);
        const isInput = (el) => el instanceof HTMLInputElement;
        const getText = (el) => (isInput(el) ? el.value : (el.textContent || ''));
        const setText = (el, value) => { if (isInput(el)) el.value = value; else el.textContent = value; };

        const sanitizeNameMap = (sheet) => {
          const out = {};
          const seen = new Set();
          const reserved = new Set(['RESULT', 'SUM', 'AVG', 'MIN', 'MAX', 'COUNT', ...ALL_LETTERS]);
          ALL_LETTERS.forEach((letter) => {
            const raw = String(sheet.names[letter] ?? '').trim();
            let base = raw || letter;
            if (reserved.has(base.toUpperCase())) base = `[${base}]`;
            let next = base;
            let n = 2;
            while (seen.has(next.toUpperCase())) next = `${base}_${n++}`;
            seen.add(next.toUpperCase());
            out[letter] = next;
          });
          return out;
        };
        const buildNameToLetter = (sheet) => { const clean = sanitizeNameMap(sheet); const map = {}; Object.entries(clean).forEach(([k, v]) => { map[v] = k; }); return { clean, map }; };
        const canonicalToDisplay = (canonical, sheet) => state.formulaMode === 'letter' ? canonical : String(canonical || '').replace(/[A-Za-z]/g, (m) => buildNameToLetter(sheet).clean[m.toUpperCase()] || m);
        const displayToCanonical = (display, sheet) => {
          let expr = String(display || '');
          Object.entries(buildNameToLetter(sheet).map).sort((a, b) => b[0].length - a[0].length).forEach(([name, letter]) => { expr = expr.split(name).join(letter); });
          return expr;
        };
        const formulaTokenFor = (letter) => {
          if (state.formulaMode === 'letter') return letter;
          const clean = sanitizeNameMap(state.sheets[state.currentSheetIndex]);
          return clean[letter] || letter;
        };

        const getSelection = (el) => {
          if (isInput(el)) return { start: el.selectionStart ?? 0, end: el.selectionEnd ?? 0 };
          const selection = window.getSelection();
          if (!selection || selection.rangeCount === 0 || !el.contains(selection.anchorNode)) { const end = getText(el).length; return { start: end, end }; }
          const range = selection.getRangeAt(0);
          const pre = range.cloneRange(); pre.selectNodeContents(el); pre.setEnd(range.startContainer, range.startOffset);
          const post = range.cloneRange(); post.selectNodeContents(el); post.setEnd(range.endContainer, range.endOffset);
          return { start: pre.toString().length, end: post.toString().length };
        };
        const setSelection = (el, start, end = start) => {
          if (isInput(el)) return el.setSelectionRange(start, end);
          const textNode = el.firstChild || el.appendChild(document.createTextNode(getText(el)));
          const range = document.createRange();
          range.setStart(textNode, Math.max(0, Math.min(start, textNode.textContent.length)));
          range.setEnd(textNode, Math.max(0, Math.min(end, textNode.textContent.length)));
          const selection = window.getSelection(); selection.removeAllRanges(); selection.addRange(range);
        };

        const activateTarget = (target) => { if (!target || activeTarget === target) return; if (activeTarget) activeTarget.classList.remove('is-active-target'); activeTarget = target; target.classList.add('is-active-target'); if (isInput(target) && document.activeElement !== target) target.focus({ preventScroll: true }); initialValueOnFocus = getText(target); updateKeyAvailability(); };
        const blurActiveTarget = () => { if (!activeTarget) return; activeTarget.classList.remove('is-active-target'); if (document.activeElement instanceof HTMLElement) document.activeElement.blur(); activeTarget = null; updateKeyAvailability(); };
        const insertIntoTarget = (text) => { if (!activeTarget) return; const value = getText(activeTarget); const { start, end } = getSelection(activeTarget); setText(activeTarget, value.slice(0, start) + text + value.slice(end)); setSelection(activeTarget, start + text.length); resetClearStage(); };
        const deleteBackward = () => { if (!activeTarget) return; const value = getText(activeTarget); const { start, end } = getSelection(activeTarget); if (start !== end) { setText(activeTarget, value.slice(0, start) + value.slice(end)); setSelection(activeTarget, start); } else if (start > 0) { setText(activeTarget, value.slice(0, start - 1) + value.slice(start)); setSelection(activeTarget, start - 1); } resetClearStage(); };
        const moveCursor = (delta) => { if (!activeTarget) return; const { start, end } = getSelection(activeTarget); const base = delta < 0 ? start : end; setSelection(activeTarget, Math.max(0, Math.min(base + delta, getText(activeTarget).length))); };
        const toNumericOrZero = (rawValue) => { const value = String(rawValue ?? '').trim(); if (!value) return 0; const numeric = Number(value); if (!Number.isFinite(numeric)) throw new Error('NON_NUMERIC'); return numeric; };

        const tokenize = (source) => { const tokens = []; const text = String(source ?? ''); let index = 0; while (index < text.length) { const char = text[index]; if (/\s/.test(char)) { index += 1; continue; } if ((char >= '0' && char <= '9') || char === '.') { let end = index; while (end < text.length && /[0-9.]/.test(text[end])) end += 1; const literal = text.slice(index, end); if ((literal.match(/\./g) || []).length > 1 || literal === '.') throw new SyntaxError('Invalid number'); tokens.push({ type: 'number', value: Number(literal) }); index = end; continue; } const normalized = char === '−' ? '-' : char; if ('+-*/^'.includes(normalized)) { tokens.push({ type: 'operator', value: normalized }); index += 1; continue; } if (normalized === '(' || normalized === ')') { tokens.push({ type: 'paren', value: normalized }); index += 1; continue; } if (normalized === ',') { tokens.push({ type: 'comma', value: ',' }); index += 1; continue; } if (normalized === '√') { tokens.push({ type: 'root', value: '√' }); index += 1; continue; } if (/[A-Za-z]/.test(normalized)) { const upper = normalized.toUpperCase(); if (!ALL_LETTERS.includes(upper)) throw new SyntaxError('Unknown variable'); tokens.push({ type: 'variable', value: upper }); index += 1; continue; } throw new SyntaxError('Unexpected token'); } return tokens; };
        const parse = (tokens) => { let cursor = 0; const peek = () => tokens[cursor]; const consume = () => tokens[cursor++]; const primary = () => { const token = peek(); if (!token) throw new SyntaxError('Unexpected end'); if (token.type === 'number') return consume(), { type: 'number', value: token.value }; if (token.type === 'variable') return consume(), { type: 'variable', name: token.value }; if (token.type === 'paren' && token.value === '(') { consume(); const expr = expression(); const close = consume(); if (!close || close.type !== 'paren' || close.value !== ')') throw new SyntaxError('Missing close paren'); return expr; } if (token.type === 'root') { consume(); const open = consume(); if (!open || open.type !== 'paren' || open.value !== '(') throw new SyntaxError('Root call requires parenthesis'); const first = expression(); if (peek()?.type === 'comma') { consume(); const second = expression(); const close = consume(); if (!close || close.type !== 'paren' || close.value !== ')') throw new SyntaxError('Missing close paren'); return { type: 'root', degree: first, radicand: second }; } const close = consume(); if (!close || close.type !== 'paren' || close.value !== ')') throw new SyntaxError('Missing close paren'); return { type: 'root', degree: null, radicand: first }; } throw new SyntaxError('Unexpected token'); }; const unary = () => peek()?.type === 'operator' && '+-'.includes(peek().value) ? { type: 'unary', operator: consume().value, argument: unary() } : primary(); const power = () => { let left = unary(); while (peek()?.type === 'operator' && peek().value === '^') left = { type: 'binary', operator: consume().value, left, right: unary() }; return left; }; const term = () => { let left = power(); while (peek()?.type === 'operator' && '*/'.includes(peek().value)) left = { type: 'binary', operator: consume().value, left, right: power() }; return left; }; const expression = () => { let left = term(); while (peek()?.type === 'operator' && '+-'.includes(peek().value)) left = { type: 'binary', operator: consume().value, left, right: term() }; return left; }; const ast = expression(); if (cursor < tokens.length) throw new SyntaxError('Trailing tokens'); return ast; };
        const evaluateAst = (node, scope) => { if (node.type === 'number') return node.value; if (node.type === 'variable') return scope[node.name] ?? 0; if (node.type === 'unary') return node.operator === '-' ? -evaluateAst(node.argument, scope) : evaluateAst(node.argument, scope); if (node.type === 'binary') { const left = evaluateAst(node.left, scope); const right = evaluateAst(node.right, scope); if (node.operator === '+') return left + right; if (node.operator === '-') return left - right; if (node.operator === '*') return left * right; if (node.operator === '/') { if (right === 0) throw new Error('DIV_0'); return left / right; } return left ** right; } const radicand = evaluateAst(node.radicand, scope); if (!node.degree) return Math.sqrt(radicand); const degree = evaluateAst(node.degree, scope); if (degree === 0) throw new Error('DIV_0'); return radicand ** (1 / degree); };
        const mapErrorToCellText = (error) => error instanceof SyntaxError ? 'Syntax Err.' : (error?.message === 'DIV_0' ? 'DIV/0' : 'Error');
        const formatNumber = (value) => Number.isFinite(value) ? (Number.isInteger(value) ? String(value) : value.toFixed(8).replace(/\.?0+$/, '')) : 'Error';
        const sheetIsBlank = (sheet) => !sheet.formulaCanonical.trim() && Object.values(sheet.constants).every((v) => !String(v).trim()) && sheet.rows.every((row) => KEY_ORDER.every((k) => !String(row[k] || '').trim()) && !String(row.Result || '').trim());
        const applyStat = (values, statName) => !values.length ? '—' : (statName === 'Sum' ? formatNumber(values.reduce((a, b) => a + b, 0)) : statName === 'Avg' ? formatNumber(values.reduce((a, b) => a + b, 0) / values.length) : statName === 'Min' ? formatNumber(Math.min(...values)) : statName === 'Max' ? formatNumber(Math.max(...values)) : statName === 'Count' ? String(values.length) : '—');

        const recomputeStatsFromSheet = (sheet) => { statCells.forEach((cell, index) => { const output = cell.querySelector('output'); const statName = sheet.stats[index] || '--'; if (statName === '--') { output.textContent = '—'; return; } const values = sheet.rows.map((row) => index < 4 ? String(row[KEY_ORDER[index]] || '').trim() : String(row.Result || '').trim()).filter((v) => v !== '').map(Number).filter((n) => Number.isFinite(n)); output.textContent = applyStat(values, statName); }); };
        const persistFromDom = () => {
          const sheet = state.sheets[state.currentSheetIndex];
          const rawTitle = (titleLine?.textContent || '').trim();
          sheet.title = rawTitle || 'Untitled';
          delete sheet.name;
          sheet.formulaCanonical = displayToCanonical(formulaInput.value, sheet);
          [...headerNameEls, ...constNameEls].forEach((el, idx) => { const key = idx < 4 ? KEY_ORDER[idx] : CONST_ORDER[idx - 4]; sheet.names[key] = (el.textContent || '').trim(); });
          constantInputs.forEach((input, idx) => { sheet.constants[CONST_ORDER[idx]] = input.value; });
          rowBindings.forEach((row, ri) => { KEY_ORDER.forEach((key, ci) => { sheet.rows[ri][key] = row.inputs[ci].value; }); sheet.rows[ri].Result = row.resultCell.textContent || ''; });
          statCells.forEach((cell, idx) => { const select = cell.querySelector('select'); sheet.stats[idx] = select?.value || '--'; });
          scheduleSave();
        };
        const renderSheet = () => {
          const sheet = state.sheets[state.currentSheetIndex];
          const clean = sanitizeNameMap(sheet);
          if (titleLine) titleLine.textContent = String(sheet.title ?? '');
          if (sheetNameLine) sheetNameLine.textContent = '';
          sheetIndexEl.textContent = `${state.currentSheetIndex + 1}/${state.sheets.length}`;
          formulaInput.value = canonicalToDisplay(sheet.formulaCanonical, sheet);
          toggleButton.innerHTML = state.formulaMode === 'letter' ? '<strong>A</strong> / Name' : 'A / <strong>Name</strong>';
          document.body.classList.toggle('formula-mode-name', state.formulaMode === 'name');
          KEY_ORDER.forEach((key, idx) => { headerLetterEls[idx].textContent = key; headerNameEls[idx].textContent = clean[key]; headerNameEls[idx].style.display = ''; });
          CONST_ORDER.forEach((key, idx) => { constLetterEls[idx].textContent = key; constNameEls[idx].textContent = clean[key]; constNameEls[idx].style.display = ''; constantInputs[idx].value = sheet.constants[key] || ''; });
          rowBindings.forEach((row, ri) => { KEY_ORDER.forEach((key, ci) => { row.inputs[ci].value = sheet.rows[ri][key] || ''; }); row.resultCell.textContent = sheet.rows[ri].Result || ''; });
          statCells.forEach((cell, idx) => { const select = cell.querySelector('select'); if (select) select.value = sheet.stats[idx] || '--'; });
          recomputeStatsFromSheet(sheet);
          updateKeyAvailability();
        };

        const computeAllRows = () => {
          persistFromDom();
          const sheet = state.sheets[state.currentSheetIndex];
          const rowIsEmpty = (row) => KEY_ORDER.every((k) => !String(row[k] || '').trim());
          let ast;
          try { ast = parse(tokenize(sheet.formulaCanonical)); } catch (error) { sheet.rows.forEach((row) => { row.Result = rowIsEmpty(row) ? '' : mapErrorToCellText(error); }); renderSheet(); return; }
          let constants;
          try { constants = Object.fromEntries(CONST_ORDER.map((k) => [k, toNumericOrZero(sheet.constants[k])])); } catch (error) { sheet.rows.forEach((row) => { row.Result = rowIsEmpty(row) ? '' : mapErrorToCellText(error); }); renderSheet(); return; }
          sheet.rows.forEach((row) => {
            if (rowIsEmpty(row)) { row.Result = ''; return; }
            try { const scope = { ...constants, ...Object.fromEntries(KEY_ORDER.map((k) => [k, toNumericOrZero(row[k])])) }; row.Result = formatNumber(evaluateAst(ast, scope)); }
            catch (error) { row.Result = mapErrorToCellText(error); }
          });
          renderSheet();
          scheduleSave();
        };

        const deleteBlankDynamicCurrentSheet = () => {
          const idx = state.currentSheetIndex;
          if (idx < 3 || state.sheets.length <= 3) return;
          if (sheetIsBlank(state.sheets[idx])) { state.sheets.splice(idx, 1); if (state.currentSheetIndex >= state.sheets.length) state.currentSheetIndex = 0; }
        };
        const nav = (dir) => { persistFromDom(); const wasLast = state.currentSheetIndex === state.sheets.length - 1; deleteBlankDynamicCurrentSheet(); if (dir > 0 && wasLast) { state.sheets.push(makeSheet(state.sheets.length)); state.currentSheetIndex = state.sheets.length - 1; } else { state.currentSheetIndex = (state.currentSheetIndex + dir + state.sheets.length) % state.sheets.length; } renderSheet(); resetClearStage(); scheduleSave(); };

        const clearAction = () => {
          persistFromDom();
          const sheet = state.sheets[state.currentSheetIndex];
          if (state.clearStage === 0) {
            if (!activeTarget) return;
            if (!getText(activeTarget)) return;
            setText(activeTarget, '');
            setClearStage(1);
            persistFromDom();
            return;
          }
          if (state.clearStage === 1) {
            sheet.rows = makeBlankRows();
            renderSheet();
            setClearStage(2);
            scheduleSave();
            return;
          }
          if (state.clearStage === 2) {
            sheet.constants = { V: '', W: '', X: '', Y: '', Z: '' };
            renderSheet();
            setClearStage(3);
            scheduleSave();
            return;
          }
          if (state.clearStage === 3) {
            if (state.acConfirmPresses === 0) {
              state.sheets[state.currentSheetIndex] = makeSheet(state.currentSheetIndex);
              blurActiveTarget();
              renderSheet();
              scheduleSave();
            }
            state.acConfirmPresses += 1;
            if (state.acConfirmPresses >= 4) setClearStage(4);
            return;
          }
          state.sheets = [makeSheet(0), makeSheet(1), makeSheet(2)];
          state.currentSheetIndex = 2;
          blurActiveTarget();
          renderSheet();
          resetClearStage();
          scheduleSave();
        };

        const numericTargets = [...constantInputs, formulaInput, ...cellInputs];
        const titleFields = [titleLine, sheetNameLine, ...headerNameEls, ...constNameEls].filter(Boolean);
        const labelEditableFields = new Set([...headerNameEls, ...constNameEls].filter(Boolean));
        const editableTargets = [...numericTargets, ...titleFields];
        numericTargets.forEach((target) => { target.setAttribute('inputmode', 'none'); ['focus', 'pointerdown', 'click'].forEach((eventName) => target.addEventListener(eventName, () => activateTarget(target))); target.addEventListener('input', () => { resetClearStage(); persistFromDom(); }); });
        titleFields.forEach((target) => {
          ['focus', 'pointerup', 'click'].forEach((eventName) => target.addEventListener(eventName, (event) => {
            if (activeTarget === formulaInput && labelEditableFields.has(target)) {
              if (event.cancelable) event.preventDefault();
              event.stopPropagation();
              const { start, end } = getSelection(formulaInput);
              if (document.activeElement === target && target instanceof HTMLElement) target.blur();
              formulaInput.focus({ preventScroll: true });
              setSelection(formulaInput, start, end);
              return;
            }
            activateTarget(target);
          }));
          target.addEventListener('input', () => { resetClearStage(); persistFromDom(); });
        });

        const handleKeyPress = (key) => {
          const label = getKeyLabel(key);
          if (key?.disabled) return;
          if (!isKeyEnabled(key)) return;
          if (key === minimizeKey) {
            const isMinimized = keypad.classList.toggle('minimized');
            document.body.classList.toggle('keypad-is-minimized', isMinimized);
            return;
          }
          if (key === undoKey) { if (!activeTarget) return; setText(activeTarget, initialValueOnFocus); setSelection(activeTarget, getText(activeTarget).length); resetClearStage(); return; }
          if (key === backspaceKey) return deleteBackward();
          if (key === leftKey) return moveCursor(-1);
          if (key === rightKey) return moveCursor(1);
          if (key === resultKey) { blurActiveTarget(); computeAllRows(); resetClearStage(); return; }
          if (label === '⌨︎') return;
          if (label === '√') {
            insertIntoTarget('√(');
          } else {
            insertIntoTarget(label === '−' ? '-' : label);
          }
          persistFromDom();
        };

        keys.forEach((key) => { let pointerTriggered = false; key.addEventListener('pointerdown', (event) => { event.preventDefault(); pointerTriggered = true; handleKeyPress(key); }); key.addEventListener('click', (event) => { event.preventDefault(); if (pointerTriggered) { pointerTriggered = false; return; } handleKeyPress(key); }); });
        const bindSheetArrow = (button, direction) => {
          if (!button) return;
          let pointerTriggered = false;
          const navigate = () => { blurActiveTarget(); nav(direction); };
          button.addEventListener('pointerdown', (event) => {
            event.preventDefault();
            pointerTriggered = true;
            navigate();
          });
          button.addEventListener('click', (event) => {
            event.preventDefault();
            if (pointerTriggered) {
              pointerTriggered = false;
              return;
            }
            navigate();
          });
        };
        bindSheetArrow(sheetNavButtons[0], -1);
        bindSheetArrow(sheetNavButtons[1], 1);

        const bindFormulaInsertButton = (button, letter) => {
          if (!button) return;
          let pointerTriggered = false;
          const insertToken = (event) => {
            if (activeTarget !== formulaInput) return;
            event.preventDefault();
            event.stopPropagation();
            pointerTriggered = true;
            insertIntoTarget(formulaTokenFor(letter));
            persistFromDom();
          };
          button.addEventListener('pointerdown', insertToken, true);
          button.addEventListener('click', (event) => {
            if (activeTarget !== formulaInput) return;
            event.preventDefault();
            event.stopPropagation();
            if (pointerTriggered) {
              pointerTriggered = false;
              return;
            }
            insertIntoTarget(formulaTokenFor(letter));
            persistFromDom();
          }, true);
        };
        headerPills.slice(0, 4).forEach((pill, idx) => bindFormulaInsertButton(pill, KEY_ORDER[idx]));
        constTopEls.forEach((pill, idx) => bindFormulaInsertButton(pill, CONST_ORDER[idx]));

        toggleButton?.addEventListener('click', () => { persistFromDom(); state.formulaMode = state.formulaMode === 'letter' ? 'name' : 'letter'; renderSheet(); scheduleSave(); resetClearStage(); });
        clearButton?.addEventListener('click', (event) => { event.preventDefault(); if (clearButton?.getAttribute('aria-disabled') === 'true') return; clearAction(); });
        document.addEventListener('pointerdown', (event) => {
          if (state.clearStage < 3) return;
          if (clearButton?.contains(event.target)) return;
          resetClearStage();
        }, true);
        if (resultHeaderTrigger) {
          let pointer = false;
          resultHeaderTrigger.addEventListener('pointerdown', (event) => { event.preventDefault(); pointer = true; blurActiveTarget(); computeAllRows(); resetClearStage(); });
          resultHeaderTrigger.addEventListener('click', (event) => { event.preventDefault(); if (pointer) { pointer = false; return; } blurActiveTarget(); computeAllRows(); resetClearStage(); });
          resultHeaderTrigger.addEventListener('keydown', (event) => { if (!['Enter', ' '].includes(event.key)) return; event.preventDefault(); blurActiveTarget(); computeAllRows(); resetClearStage(); });
        }
        editableTargets.forEach((target) => target.addEventListener('blur', () => { if (activeTarget === target) { target.classList.remove('is-active-target'); activeTarget = null; updateKeyAvailability(); } persistFromDom(); }));
        statCells.forEach((cell, idx) => { const select = cell.querySelector('select'); select?.addEventListener('change', () => { state.sheets[state.currentSheetIndex].stats[idx] = select.value; scheduleSave(); resetClearStage(); }); });
        document.addEventListener('keydown', (event) => { if (event.key !== 'Enter') return; if (!activeTarget || !editableTargets.includes(activeTarget)) return; event.preventDefault(); blurActiveTarget(); computeAllRows(); resetClearStage(); });

        (async () => {
          const saved = await asyncStorage.get();
          if (saved?.sheets?.length) {
            state.sheets = saved.sheets.map((sheet, idx) => hydrateSheet(sheet, idx));
            state.currentSheetIndex = Math.max(0, Math.min(saved.currentSheetIndex ?? 0, state.sheets.length - 1));
            state.formulaMode = saved.formulaMode === 'letter' ? 'letter' : 'name';
          } else {
            state.currentSheetIndex = 2;
          }
          while (state.sheets.length < 3) state.sheets.push(makeSheet(state.sheets.length));
          renderSheet();
          resetClearStage();
          updateKeyAvailability();
        })();
      })();
    </script>
  </body>
</html>
